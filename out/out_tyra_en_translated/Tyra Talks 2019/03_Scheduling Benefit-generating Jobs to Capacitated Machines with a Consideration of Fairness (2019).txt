Welcome to today's Taira Talk.
Today is February 16, 2019.
Our speaker is Professor Kong Lingjie.
Professor Kong Lingjie is a Vice-Professor of Information Management at National Taiwan University.
He was a Ph.D. student at Berkley University in the U.S.,
and a master's and master's student at National Taiwan University.
His research focuses on competition theory and professional research,
and discusses decision-making in the business sector.
We are delighted to welcome Professor Kong Lingjie.
Let's welcome Professor Kong Lingjie.
Let's give a round of applause to welcome Professor Kong Lingjie.
Thank you all.
Can I start now?
Yes, you can.
Thank you all for coming to this talk.
This is a rare opportunity for me.
When I was a Ph.D. student or when I started teaching,
I would like to listen to all kinds of strange talks.
The so-called strange talk is different from my own field.
From a certain perspective, it is very necessary for people like us.
Because we study information management.
Let me briefly introduce information management.
We study information technology at the Department of Management.
We want to use information technology to see if we can do something in the field of management.
Basically, it is a cross-field field.
So we often listen to all kinds of other talks,
and we can get a lot of inspiration.
Sometimes it doesn't inspire at all, but it doesn't matter.
Just treat it as a broad text.
So when I was a Ph.D. student,
Jason often introduced me to some physics-related knowledge.
Although I almost forgot everything,
I still feel very happy about this exchange.
Today, I will use this opportunity to introduce my research field to you.
This is of course one of the studies, but I personally quite like it.
It was done by a student of my previous master's class named Liu Qiwei.
This is actually his master's thesis.
Of course, we did it together in the process.
As a result, I think this study is still quite good in terms of academic results.
So a Ph.D. student from NTU or a Ph.D. student who is serious can really achieve quite good results.
Okay, what is this study about?
The theme of this study is called Job Allocation with a Consideration of Fairness.
It is a work allocation problem that considers fairness.
Let's take a look at what this is about.
Today, when we want to do job allocation, we usually have to consider a lot of issues.
For example, let's assume that the job is a toy car.
In general, I am a worker.
I make a toy car.
If I make a toy car that takes two hours,
I sell it to the buyer, the consumer.
The buyer will pay me.
So the job is to spend time to make something, sell it, and change the money.
It's that simple.
Today, the reason why we started to discuss this topic was probably the year I came back to Taiwan.
At that time, I met a company in Zhukou.
There are five or six supply factories.
There are many factories in Nankou and China.
Sorry, it's not a supply factory.
It's a company that makes LED chips.
The problem with this company is that its customers will place orders with it.
For example, this order says I want 100 toy cars.
Or how many LED chips do I want?
The company's owner is responsible for allocating work to each factory.
When allocating work, there will be a so-called fairness issue.
Every factory wants to fight for the so-called better order.
Some orders have a work load.
That is, you have to spend a lot of time.
Benefit is that the cost-effectiveness or the degree of easy-to-earn money is very low.
For example, some relatively traditional things are produced.
This kind of profit is small and time-consuming to do.
Everyone doesn't like this.
Or, for example, the yield rate is very low when doing it.
It's difficult and everyone doesn't like it.
So these factory managers are all going to be reviewed in the end.
Then they will really happen.
They will go to the head of the company and scold him.
Why is this order divided to others and not to me?
So from that time on, I realized that when this work allocation happened between people.
He did encounter some interesting issues.
It is not encountered in traditional work allocation.
Traditional work allocation is usually at the beginning.
Whether it's an employee or a public person.
They are talking about this work allocation.
It's more often that I assign the work to the machine or the CPU.
Then they naturally don't have any fair or unfair questions.
Does everyone listen to you?
When you assign work to people, people will definitely care about fairness.
In addition to caring about their own workload and their own revenge.
I care about how I compare with others.
It's probably like this.
That's why everybody wants to earn more money.
So in the food problem just now.
Motivate us to do this study.
After that, we slowly simplified it into the following topics.
In other words, we will have a lot of work.
Every work will have the time it takes.
And how much money can be made after this work.
For example, it takes two hours to make this small car.
Then you can make so much money.
It takes 2.5 hours to make this medium car.
You can make more money.
The big car is the most advanced.
It takes 4.5 hours to make the most money.
So there are all kinds of work.
Some are more difficult to do.
Some make more money.
Then we have a lot of so-called factories.
Their capacity is limited.
You can't give all the work to the same factory.
So in this problem.
We want to do work allocation.
Then you might think.
Is there any other situation?
I also want to do this kind of work allocation.
In fact, there are quite a few.
Here are a few examples.
These examples were later seen one after another.
The first example is Kaohsiung Port.
Kaohsiung Port is a project we are discussing now.
Kaohsiung Port is probably like this.
We are talking about the so-called flood.
If you don't know much about flood.
If you are interested, you can google it.
Is to find out what the flood is doing.
Probably like this.
Suppose there is a boat here today.
This boat wants to come to Kaohsiung Port.
Then stop like this.
The route I am drawing now is Port 2.
This place is Port 1.
Port 1 is closer to the north.
So this is near Shanduoshang Circle.
This place is probably like this.
This one here.
Is a miracle that everyone may have been to.
In short.
When this boat wants to come in now.
He can't come in directly.
He must be in this place.
Waiting for the flood people to go up.
Flood people are those who live near the pier.
The senior captain.
They used to have many years of boat.
The experience of running around everywhere.
Then later.
After turning into a flood person.
They will live near the port.
When there is a boat coming in.
Flood people will be in the open sea.
Will take a small boat to the open sea.
Temporarily take over this boat.
With the captain of that boat.
Drive the boat in.
The reason for the need for flood people.
Of course it is because of a port.
Local people know better.
So these people in Kaohsiung Port.
Or flood people.
They know more about the situation in Kaohsiung Port.
Then inside Kaohsiung Port.
The setting of this port.
And so on.
So he can bring the boat in like this.
It's the same to take it out.
Then the boat moves between the pier.
It's the same.
All need flood people.
In terms of the size of Kaohsiung Port.
Kaohsiung Port has about 40,000 boats a year.
Then there are 40 flood people.
Then they are obviously.
All the work in this year.
It's going to be divided to these 40 flood people.
There are more than 100 boats on average every day.
Then there are more than 100 boats.
Come in and out.
Scattered within 24 hours.
Then these flood people.
I'm going to finish them one by one.
That's it.
Why is there a so-called fairness problem here?
A boat comes in.
A flood person to bring.
Some boats are difficult to bring.
For example, a boat carrying oil.
Boat carrying dangerous goods.
Or a super big boat.
This kind of boat is difficult to bring.
Some boats are very simple.
Then it's more troublesome to get to the port.
It's easy to get out of the port.
Everyone imagines parking on the side of the road.
Of course, parking on the side of the road is easy to drive out of the road.
It's hard to park.
So it's obvious that your work is simple and difficult.
So there are different bonuses.
What about the flood people?
He gets some bonuses every time he brings a boat.
That's tens of thousands of dollars less.
Hundreds of thousands of dollars more.
This amount is amazing.
It's a lot worse.
So for the flood people.
If they want to allocate their work.
What they care about most is not the degree of overtime.
Or the relationship between me and the merchant.
They all consider these.
But what they care about most.
Or something that can't be ignored.
Is it fair to divide these jobs?
I can't do some races every time I go.
Then do something that is difficult to do.
The salary is relatively low.
Then give it to him every time it's done.
That won't work.
So this is an example of job allocation.
I divide the work.
Everyone has to be able to eat and play.
Can't risk driving.
At the same time, we have to consider everyone's so-called money.
Can't be too different.
Or can't be too different from his job.
A similar example is a massage shop.
There will be a lot on the side of the road.
Whether he is a blind man or not.
Or this is a special massage for you to relax.
Then you can relax after work.
This kind of massage shop.
Massage shop is generally you go in.
It's quite a job.
Then there are a bunch of massage masters inside.
Usually there are a few people in turn.
So they have to be divided.
Some shops will use the way of turning around.
The way of turning around may be good or bad.
But it's the same.
He will definitely encounter a problem of fairness.
You can't do the same job every time.
Then give it to another person.
Finally, there is the so-called social enterprise.
The meaning of the word social enterprise is probably to say.
The purpose of the establishment of this company.
Is to promote social welfare.
Instead of his own company to make the most money.
For Taiwan.
Just give an example.
There is a company called Dazhi Culture.
He basically sells the so-called Dazhi magazine.
This is called Big Issue.
This is not unique to Taiwan.
His feature is.
He put the newspaper magazine.
This is the Dazhi magazine.
He handed it to the tourist.
Let the tourist sell it.
This mechanism itself is not the point.
The point is.
Since you are giving these jobs to the so-called tourist.
Of course, your goal is to hope that every tourist can make a certain amount of money.
Instead of maximizing the company's total profits.
So in many of these examples.
We can all see.
Basically there is a person.
He is a central control unit.
He is responsible for the distribution of work.
The traditional distribution of work is.
I have some subordinates.
I will divide the work.
They will be obedient.
Then they will finish their work after they have finished listening.
Then we have profits.
There is a revenge, etc.
Then I maximize my personal total profits.
It used to be like this.
But in some topics.
For example, in this topic we consider.
You can also see that a lot of time.
The distribution of work is not actually concerned about overall efficiency.
In fact, it is fairness.
If that's the case.
Maybe you need a new way.
Or you need to adjust the old way.
It's probably like this.
So, uh.
In terms of this question.
Job this thing can be said to be a love and hate.
On the one hand, it is that you have to spend time doing your job.
But it is also a precious resource.
Because doing the job is making money.
So, we have to use a good way.
Divide the job to our work units.
Then we are on the word.
I will still call these work units machine.
Because in this schedule.
Scheduling in this field.
That's what everyone calls it.
Just call him a machine.
But we know ourselves.
Our so-called machine is here.
More like an agent or an employee.
Like this.
So, we don't just consider.
We don't just want to maximize the total profit.
The main thing is to consider fairness.
So, our machine will have the so-called limited capacity.
It's just you.
One day's work is limited.
So you can't do more than your load.
Work.
So, we.
The setting in this place is.
As long as you have enough capacity.
Then you will want to do more work.
Just like a masseur or a waterman.
So, you are on duty today.
Then, as long as your workload can be replenished.
You want to do a little more.
Make more money.
That's probably what it means.
Then, we assume that the work cannot be split.
That depends on the situation.
But in the example we just talked about.
Massage master usually.
His work will not be divided.
You go in.
Someone will give you a foot massage.
Or someone will help you relax your shoulders.
He won't relax his shoulders until two-thirds.
Suddenly change the next person.
Right?
It's usually like this.
That's not to mention Kaohsiung Port.
He helped you bring the boat in from the sea.
Stop well.
He won't change a waterman halfway.
This is a waste of time.
So, we assume here.
Job can't be divided.
In some cases, of course.
For example, there is a customer who orders with me.
He wants 100 toy cars.
Of course, I can give it to factory A and factory B.
Each makes 40 and 60.
Right?
But in terms of food.
Sometimes the company doesn't want to split the order like this.
Because it's obvious that it's going to cause some homework.
Difficulties and troubles.
In addition to the academic.
We can easily prove.
If the work of this problem can be freely distributed.
And if there is no cost.
Then this problem will be very.
The existing method can be easily solved.
So whether from the perspective of food or from the perspective of theory.
Support us to do this setting.
In some cases, work can't be divided.
Then we will also discuss this point.
So the overall goal of our question is.
I want to maximize this so-called minimum benefit.
Among machines.
This thing is a core setting of our topic.
So let's talk about it.
Why are we doing this?
Uh, basically.
I have a question.
You can come.
Uh, I can't split that assumption.
It will lead to that.
Because you just said that if you can split it.
It can be easily solved.
So what you mean is.
For example, if you can split it to infinity.
Basically, it's a concept of division.
You divide it by how many agents in total.
Then that's it.
Is it like this?
A little bit more complicated than that.
Uh, that's what we're doing today.
Uh, uh, uh, uh, uh, uh, uh, uh.
First, from a technical point of view.
Uh, we'll show you the mathematical model later.
So you'll see that we're going to have a whole number of planning problems.
So if the work can be divided today.
It will become a linear planning problem.
That linear planning problem already has.
Uh, everyone can accept it.
A good way to solve it.
Uh, so this is.
A more academic answer.
So what you just said is.
So-called it's all gone.
Similar similar.
Uh, although it's not a very.
It's not always possible to get the best solution.
But it's almost the same concept.
So that's it.
If today's job can be.
Any partition.
And then to infinity.
And then there's no cost.
If you want to divide it by a few points.
Indeed, this problem does not need to be studied.
Like this.
Is that okay?
Did I turn it on?
Oh, I turned it on.
Hey, can you hear me now?
There is.
Oh, okay.
So good.
Then I have another small problem.
I just got that.
The other small problem is.
If you have this assumption.
It sounds like it's still you.
You're still going to use it next.
Right?
Or will you say.
It's going to be like throwing some.
For example, like.
Material simulation.
And then run some.
What kind of simulation?
And then look at some.
The results of the statistical distribution.
Still.
You will still tend to.
Is to calculate the result.
Yeah.
OK.
Yeah, because you just said.
OK, good.
That's it.
Thank you.
Thank you.
That's right.
That's what we're going to do.
This study is basically.
A study of homework.
That is, as you will see later.
The main task is.
Write a mathematical model to describe this problem.
And help him write a algorithm.
Oh, uh, you just mentioned Monte Carlo.
Ah, this value simulation and so on.
Because of our problem.
You'll see it later.
We are a deterministic problem.
So, uh, you don't need to use these.
Uh, statistical distribution, and so on.
It's basically a standard algorithm problem.
Oh, but we'll talk about it later.
Then we'll see you later.
That's above this line.
Basically, it's about the setting of our topic.
We have a bunch of jobs.
We have a bunch of so-called machine or agent.
And then, uh, we think about the so-called fairness that agent cares about.
That fairness needs a measurement.
That is, after we distribute the work, they make money.
After that, we need to measure the so-called fairness.
There are many ways to measure fairness.
For example, there are people in academia who do this.
That is, everyone makes money.
The person who makes the most money.
Don't make the most.
Don't make too much.
Or the person who makes the most and the person who makes the least.
Don't be too different.
Or the money everyone makes.
Don't be too big.
Oh, and so on.
So you can write a lot of goals.
For example, I minimized.
Maximum benefit.
It means that I have ten people.
And then everyone makes money.
That ten people make the most money.
See how much money he makes.
I'm going to minimize the money he makes.
Or I minimized.
Maximum benefit.
Minimum benefit.
Like this.
Oh, there's one person who makes the most.
There's one person who makes the least.
And then we're going to minimize this gap.
Or I'm going to minimize.
Variance of benefit.
Oh, that's fine.
These things are OK.
But in our topic.
If we choose these goals.
Then we have to deal with benefit at the same time.
I'm sorry.
We have to deal with fairness and efficiency at the same time.
It's going to be a lot of trouble.
Why?
Because if we use these goals.
Then the best solution will become very natural.
Don't do all the work.
Don't do it all.
Everyone makes $0.
This is also the best.
This is also the best.
This is also the best.
All the goals are optimized by you.
Can't be optimized anymore.
But efficiency is 0.
It will become that.
We have to use other ways to limit.
We can't give up our overall efficiency completely.
So, in the end, we use this.
The goal is this.
This is my job for everyone.
Everyone makes money.
I see which unlucky guy makes the least.
I'm going to maximize that unlucky guy.
I make money.
If that's the case.
First of all, the poorest person will not be too poor.
The worst person will not be too bad.
This is quite in line with our fair intuition.
The second is if you want to maximize as much as possible.
The money of the person who makes the least money.
Naturally, other people will not make much more than him.
Because in this case, this goal will not be satisfied.
That's the end.
If my goal is to maximize the minimum benefit.
In fact, we will show it to you at the end.
The overall efficiency will not be too different.
We can ask the same question.
I maximize efficiency or maximize fairness.
If we use this setting to maximize fairness.
That efficiency will not go anywhere.
That's about it.
So we will start with this goal.
Then we are today.
Uh, because, uh, most of us.
This friend is not doing the so-called research in this field.
So, of course, we choose the gold.
How do you say it?
It's easier to understand.
So I'll do a few more things later.
I'm going to write down the formulation of this problem.
You mean to use simple mathematical formulas.
Let's define exactly what I just said.
After that, there is a model.
It will allow us to prove that it is NP-hard.
That NP-hard is a CS.
Or, uh, it's the word used by people in the field of computer science or research.
That's probably what I mean.
I want to prove that this problem is very difficult.
Oh, is it that we can't look forward to it?
You can get the best result within a reasonable time frame.
So we're going to design a so-called heuristic.
That is to say, oh, this problem is so difficult that we can't find the best solution.
So let's find a feasible solution.
And then we'll take a look at this feasible solution.
Let's analyze its performance.
It's probably like this.
That analysis of performance is, uh, how do you say it?
It's also very difficult.
So we're just going to pick one of the little parts of our whole study.
It's the easiest part to understand, but it's also the most essential part to share with you.
That is to say, the same problem.
You can also design a heuristic.
I can also design a heuristic.
He can also design a heuristic.
It's easy to design a heuristic.
But what we want to do is to find the theoretical nature of our heuristic.
See how good it can be or how bad it can be.
Hopefully, this will give us a better understanding of the heuristic.
That's about it.
Okay.
So let's formulate this problem.
Uh, our field is called homework research.
Operations research.
At the beginning, it was.
Linear programming that everyone learned when they were young.
If you have no impression of linear programming, you probably did something like this when you were a kid.
You have x and y.
And then they're limited.
That is, for example, x plus 2y.
Uh, sorry, this is 2x plus y.
And then x plus 2y, and then x plus 2y, and then x plus 4, and so on.
So you're going to have a feasible region, x is greater than 0, y is greater than 0, and so on.
And then you're supposed to have a goal, like I want to maximize x plus y.
Yeah, well, then you're going to have a line, and then you're going to push it this way, and then you're going to get the best solution.
This thing is linear programming.
Generally speaking, the homework research method is that I try to write the problem into linear programming, non-linear programming, and so on.
And then we use all kinds of methods to solve it.
So now we're going to do something similar.
I'm going to define my decision problem.
The goal is limited and there are character variables.
So let's go back to the topic we just talked about.
I have a group of people, agents or machines.
It's my work unit.
And then I have a group of jobs that I'm going to divide.
And then, today, I have a few jobs.
I have a few machines.
So m is machine, and the other symbol n is job, like this.
And then I have a limit on every machine.
I work eight hours a day, this kind of thing.
So I have a limit on my work time.
This is called K, called Capacity.
Every job has the work time it needs.
So it's called CJ.
This is usually called Processing Time in Scheduling Literature.
How long does this job take to finish?
And then JobJ.
JobJ has its benefit, which is how much money I can get after I'm done.
So our task is to determine the so-called XIJ.
XIJ is a so-called 0-1 variable.
It's for every job and every machine.
I ask myself if I'm going to let machine I do JobJ.
If so, that means I'm going to assign J to I.
Then I'm going to set its value to 1.
Otherwise, I'm going to set it to 0.
Something like this.
Now that we have this role variable,
Let's see how we're going to describe what we just talked about.
The target room, the limit room, and so on.
This problem is very simple to describe.
Let's look at the bottom here.
The first thing is that for every machine or every agent.
The total workload I assign to it cannot exceed its work time.
How do you say that?
XIJ is equal to 1, which means I assign J to I.
So I ask every job,
Did I assign J to this I?
If so, then this work time has to be added up.
So the total work time I get cannot exceed the amount I can recover.
This is the limit room 1.
The limit room 2 is that every job is assigned to at most one machine.
So I look at all the machines that I may be assigned.
XIJ can only have one person at most.
Here, XIJ, we set it to be either 0 or 1.
It can't be 0.3 or 0.8 or something like that.
This means that this work cannot be divided.
The final goal is here.
I want to maximize the so-called minimum benefit.
How do you say that?
For every I, for every machine,
I'm going to calculate how much benefit I get.
If XIJ is 1, it means I got that job.
I got that job, I did it, and then I got this benefit.
So XIJ is the benefit I get.
You earn $8, I earn $5, he earns $16.
The unluckiest of us is $5.
The goal value is 5.
I want to maximize the money earned by the least amount of money.
It's probably like this.
So this place.
There are a few values.
It's here.
Let's review it.
I basically maximize the minimum total benefit among machines.
Then the first one is capacity constraint.
That is, my work time is limited.
The second one is job can be done only once.
So it's a job that can only be done once.
It can only be distributed to one person.
And then finally, the job can't be split.
It's probably like this.
Let's jump out here and talk about a few things.
We have a few settings here.
BJ, CJ and K.
This is equivalent to assuming that each machine is exactly the same.
So their work time constraints are the same.
And then every job is, uh, every job is assigned to you or assigned to me.
The profit is the same.
And then how long does each job take?
It's the same.
These settings are sometimes established and sometimes not.
For example, K.
What about K?
If I'm talking about a massage master today, it's not necessarily.
Some people might be able to do it for eight hours a day.
Some people can only do it for four hours a day, right?
BJ is doing a job today.
How much can you charge the customer?
This may be the same.
Massage master.
But this one person comes in.
Then you press, you are 400 yuan, I press, you are 400 yuan.
OK.
That CJ is not necessarily the same.
Not necessarily the same or not the same.
For example, a massage master is usually a job.
30 minutes, 20 minutes, and so on.
So that CJ will naturally be the same.
But if today is, for example, a drinker, a drinker.
Some people have better skills, some people are faster, some people are slower.
This is possible.
But in the end, in fact, we have done it before.
K, you can make it different for everyone.
This is OK.
CJ, you can become C.I.J.
BJ, you can become B.I.J.
As long as you meet some reasonable settings, this problem can still be dealt with.
But today, because of the time limit, we don't talk so much.
We just assume that BJ is the same for everyone.
CJ is the same for everyone.
The so-called everyone is the same.
It's divided for you or for me.
We make the same money.
That's what it means.
And then finally, K, everyone is the same.
Let's assume this thing.
Then, uh, I just mentioned that if this job can be divided.
Then this place will become X.I.J.
Between 0 to 1.
At this time, this problem is that you can move a little bit more.
It will become a linear program.
It becomes a linear program.
That linear program will be the general commercial server.
It can be solved.
Well, there's nothing to study about this problem.
Okay, so today, uh, I'm going to skip it.
So today, after that question, in our field, first of all, we have to prove that this question is NP-hard.
The meaning of NP-hard, of course, I'm not going to talk about the details here.
But what it means is that if you can prove that a problem is NP-hard.
It means that people in the academic world basically recognize that this problem is not the best solution within a reasonable time range.
You mean that the complexity of this problem is very high.
That's probably what it means.
Okay, so the question just now, if you're not in this field, it's probably hard to imagine why it's so complicated.
Okay, why is it so difficult to get the best solution?
So let's just describe this proof a little bit.
So here's the problem.
I'm going to assume that my question just now is a little bit simpler.
A special case.
There are actually only two machines in this special case.
And these two machines are uncapacitated, which means that their workload is infinitely large.
Or far larger than all the workload.
So in this case, our problem will become the so-called partition problem.
What does it mean?
My workload is already limitless.
So the workload limit no longer exists.
I only care about how many benefits these jobs will get.
Work 1 can earn $3, work 2 can earn $4, and so on.
And then my fairness issue is that I'm going to divide this pile of benefits as evenly as possible to two people, right?
It's best to stack it up like this.
This problem is called partition problem in mathematics or computer science.
I give you a bunch of integers and you divide it into two piles.
Try to make these two piles the same size.
In fact, this problem is NP-hard.
As long as you have enough numbers, you can't find a good answer to this problem.
You divide it, you divide it, but you can't tell.
And then you can't even tell if they can be divided into two piles of the same size.
It can't be done in a reasonable amount of time.
So even partition can't do it.
Our problem is more difficult than partition.
It's just that we can't do it any more.
That's about it.
Well, in that case, let's find a heuristic algorithm.
This thing is what I'm doing now.
Hey, I have a question.
Can you go back to the last page?
But the problem you have to deal with is that you just have to maximize the minimum benefit.
You don't have to be partition.
In this case, it's still NP-hard.
Can you fully correspond to this partition problem?
Hey, that's a good question.
We're maximizing the minimum benefit.
So we're doing this thing in general.
But when we only have two machines.
We're going to want to make them as big as possible, right?
Yeah, if we can't make it the same size.
Then this thing is not fair in some sense.
Or the way we can maximize the minimum benefit is to make them the same size.
That's a good answer.
But you might have that thing.
Okay, I know.
Yeah, yeah, yeah, yeah, yeah, yeah, yeah.
Let me correct this partition problem.
It has two versions.
Version one is that I give you a bunch of numbers.
Ask you if you can divide them into a pile of the same size.
Version two is that I give you a pile of numbers.
You help me minimize the difference between these two numbers.
Like this.
OK.
And then these two questions are all in the same place.
OK, OK, OK, OK, OK.
In fact, version one is relatively simple.
Version one is the decision problem.
It's a yes or no.
Version two is the optimization problem.
You have to find a set of distribution methods.
So our question is version two of the expansion version.
Like this.
OK, good.
Thank you.
OK, and then it's here.
So today we're basically not going to look for the best solution.
So we're going to look for the so-called feasible solution.
Use heuristic algorithm.
Heuristic is an inspiration algorithm in Chinese.
It's actually an experience law.
There's a lot of numbers here.
How do you divide it better?
Well, I don't know.
But why don't you just divide it like this?
It's usually pretty good.
That's probably what it feels like.
Heuristic algorithm sounds like a waste from an academic point of view.
It's just that if it's a very, very simple rule-based algorithm,
People think it sounds like it's very simple.
Is that really okay?
But in fact, it's almost always done that.
Uh, for the example of Kaohsiung Port.
When we were discussing with them, we said, oh, that sounds like a job allocation problem.
So let's design the algorithm.
And after a while, they found out that they were very worried that the algorithm would be blacked out.
That is to say, someone wrote a software to do the job allocation.
What if the person who wrote the software colluded with a few of them?
And then it's a lot of favoritism.
What do you do with those inspirations?
Yeah, there's no way to solve it.
So that's to say, if this algorithm is implemented into the job allocation between the drinkers,
The algorithm must be very simple and easy to explain.
Everybody can understand.
So today, when a job is assigned to A instead of B,
The file with the history record and the algorithm must be able to explain why it is assigned to A instead of B.
There is such a requirement.
So in this case, it becomes that you can't use a complicated algorithm.
You have to use a relatively simple but effective algorithm.
So you can't use that kind of neural network.
You just have to use a relatively simple algorithm.
And then it can get a certain effect.
Okay, so let's find a simple algorithm.
But what if you want to design an algorithm for that question?
Look at the file.
So look at the file.
In 1966, someone studied a very similar problem.
You have a bunch of machines.
They all look the same.
But you have to minimize and make span.
What does that mean?
That is, you have a bunch of jobs.
These jobs all have the so-called CJ, which is workload.
So every job has to spend a certain amount of time.
At that time, there was no benefit in that problem.
You just divide a bunch of work into a bunch of machines.
And then hope to minimize the total time of the machine that takes the longest.
So this problem is on the academic side.
It's kind of like this kind of problem.
And then there was a man.
He did a similar problem in 1982.
He's the same.
There's only workload at work.
But he's the one who maximizes the satisfaction of that person.
That is to say, after the job is done, there is a person who does the least.
I'm going to maximize his work.
So.
These two questions are very similar, right?
It's a bunch of work.
It takes time.
Graham, he's the one who minimizes the longest.
Dual Mayor is the one who maximizes the shortest time.
But in short, it's all about fairness as far as possible.
So the way they use it is very simple.
That is to say, uh, what we use today is called LPT.
This algorithm is that I arrange the work from large to small.
According to the formula.
And then after the sequence, we start to divide the big work.
Every time you want to divide it, you divide it to the most comfortable and relaxed person at the moment.
It's probably like this.
And then it's over.
This algorithm is very intuitive.
If you divide it to the most comfortable person every time.
Then his current total work is the smallest.
Of course, you'll be the most balanced.
And then the work has to be arranged from large to small.
That makes sense, too.
Because small work can finally insert air.
So let's take a look at the example.
Suppose I have four jobs and two machines.
The four jobs are 7542.
And then I have two empty machines.
That 7542 has been arranged, right?
So the workload is 7.
I'm going to give it to the machine.
At this time, I'm going to give it to the machine.
Because the machine is more comfortable now.
He just didn't work.
And then the next thing is work 3.
Work 3 is going to be given to the machine.
Because the current workload of the machine is relatively small.
And then the last job 2.
Of course, the job 2 is given to the machine.
So that's how simple the algorithm is.
So based on their longest processing time.
Then we'll fix it a little bit.
We'll change it to Capacitated Highest Benefit Job First.
It's called CHBF.
This method is to say.
We have the so-called benefit today.
And then there's no, uh, sorry.
And then our goal is to balance the benefit.
So when we arrange the jobs from large to small.
It's in the order of benefit.
OK.
After we're done, every time we're going to divide the job.
Just divide it to the current accumulated benefit.
The smallest job.
We'll give it to him.
So when you divide it, you have to see if it has capacity.
If the capacity is not enough.
Then we'll give it to the second順位.
And then we'll give it to the third順位.
And so on.
Well, you've been doing this thing over and over again.
Until we finish the job.
The so-called division is also possible.
It's not finished.
Because every machine has a capacity limit.
So there are some jobs that can't be done in the end.
It's also very possible.
Well, if a job can't be given to any machine.
Then we'll throw it away.
Well, there's nothing we can do about it.
It's probably like this.
So.
Uh, in academia, we can easily analyze the complexity of this problem.
But even if you don't write that formula to analyze.
It's okay.
It looks very simple.
Job sequence.
And then we divide the divide divide divide divide divide divide.
So this method is very easy to implement.
Well, suppose we have this today.
The same.
We have two jobs and, uh, sorry, four jobs and two machines.
So let's try it.
The capacity of these two machines is eight.
Uh, at most, you can only do eight hours of work.
And then, four jobs, nine dollars each.
Nine dollars, five hours, six dollars, six hours, three dollars, three hours, two dollars, two hours.
Two.
So we're going to start with this nine-dollar job.
Take it first.
Okay, so he'll give it to the machine first.
And then the six-dollar one is given to the machine.
And then there's the three-dollar one, right?
The three-dollar one is supposed to be given to the machine.
Because the machine only makes six dollars at the moment.
But I can't divide it when I want to.
Because he can't eat it.
Then he had to give it to the machine.
And then the last one was given to the machine.
So this algorithm is probably running like this.
Okay, so that's what today's questions are.
It's just a random question for you.
It's easy for you to design algorithms.
But it's very difficult for you to show him good.
So what's good?
There are usually two kinds of measured indicators.
I'm going to finish these two pages.
That's about it.
That is to say, I randomly give you 10 million jobs.
And then you just, uh, I randomly produce these jobs.
You just give me a row.
And after that, we can calculate the target market value.
How much is it, right?
At the same time, we can also find some benchmark algorithms.
Let's compare it with everyone.
So we have 100 people.
100 people each propose 100 algorithms.
So we just throw it down every time.
And then it depends on whose algorithm usually performs better.
Okay, so that's the first plan.
The second plan is that we use a more theoretical proof.
The method is to find the worst case performance of the algorithm.
What he means is probably that for your proposed algorithm.
Can you prove that no matter what strange instance is thrown to you.
Your performance can be good to a certain extent.
That is to say, I know that my algorithm will not find the best solution.
But no matter how bad it is, it can't be bad to a certain extent.
That's probably what it means.
What about us?
This so-called worst case performance guarantee.
If you can find it.
It can give us some psychological confidence when we use algorithms.
In other words, I also know that the algorithm I found is not the best solution.
But it's not too far from the best solution.
That's probably what it means.
Okay, so.
We used to have Graham, this dual mayor.
They all found the so-called performance guarantee.
In Graham's case, I'm going to do my job today.
I'm going to minimize make spend.
Minimize the total cost of the person who does the longest.
At that time, he can prove that his algorithm's performance guarantee is 4.4.
133% means that if the best solution is 100.
He will find at least 133 or less.
Because it's a minimization problem.
So the smaller your target market value, the better.
He can guarantee that his solution is at most one-third of the best solution.
That dual mayor.
Sorry.
The dual mayor is that his problem is the other way around.
So it becomes three quarters.
In other words, if the best solution is 100.
Your mayor's solution is at least 75 or more.
That's probably what it looks like.
And then there were some other people who did some refinement.
So our goal is the same.
We want to help our algorithm find a performance guarantee like this.
As a result, of course there is.
We have this performance guarantee in all kinds of situations.
So let's just talk about one.
That is to say, if today our job benefit.
With workload is a linear relationship.
That is to say, a car is 5 yuan, two cars are 10 yuan, three cars are 15 yuan.
If you do a few hours, you will get various benefits at the bottom of the line.
Oh, if it's this situation.
Then our algorithm.
We can guarantee one-third.
That is to say, if the best solution is 100.
Then we can do at least 50 or more.
That's probably what it looks like.
Then there is a vote here.
Then I'll skip this one.
Then we want to emphasize one thing.
That is.
The best solution is 100.
Then you guarantee more than 50.
It sounds pretty good, right?
Oh, at this time.
We have to explain one thing.
That is, 50 is actually the most ideal situation.
That is to say, one-third of the guarantee is the limit of our algorithm.
Oh, what do you mean?
Suppose I have a lot of machines today.
Then these machines, they are basically.
Uh, he.
Suppose I have several machines.
M machine.
Then I have two M plus one job.
Among them.
A lot of work.
2M work is just half the capacity.
Only a little bit bigger.
Then if today is.
To do this allocation.
Then I use my algorithm.
I'll put the biggest one in first.
Then this one will just fit.
Can't fit any other work.
The other machines will just fit two.
Two.
Oh, so my solution.
It's probably half of the best solution.
That's what it means.
We just found 1 in 2.
This solution, this performance guarantee.
There's no way to improve it any more.
Oh, this is the limit.
But there's still no way to answer.
Some of the other people's questions.
It's just that you might think.
One-half is still very small.
The maximum solution is 100.
You can only find 50.
Does that really work?
At this time, we can do some later.
Value experiment.
To prove that he is actually.
In average, it's usually not too bad.
Oh, so like this kind of research.
I'm going to do a numerical study later.
That is, then we will randomly produce a pile of instances.
Throw it to this algorithm.
And then, after the algorithm spit out the solution.
We're going to throw this pile of instances into a server.
Let the server run for three days and three nights.
Find the best solution.
And then let's take a look at my algorithm.
0.2 seconds out.
With the server running for three days and three nights.
The best solution that came out.
How much difference is there?
That's basically through all kinds of research.
It's probably all about this relationship.
Oh, here.
That is to say.
Our algorithm.
The fairness index found.
With the fairness index found by the best solution.
It's usually two percent.
Four percent, eight percent, and so on.
And then?
Uh, in some particularly.
In a tight situation.
Our algorithm.
The worst of the worst is probably to find 90 percent.
Around the solution.
That is to say, the best solution is 100.
He found 90.
It's probably like this.
And then in a relatively easy-to-handle situation.
He can find 98 percent, 97 percent, and so on.
Oh, that's because the time is up.
So I'm not going to go into the details.
But generally speaking, what we do in this type of research.
It's just like that.
You have a problem.
The old man didn't solve it.
Then you solve it.
After you design a algorithm.
From a theoretical point of view.
Make sure he's not too bad.
And then use a numerical experiment to say that he's actually pretty good.
It's probably like this.
Okay, so to sum up.
Oh, sorry.
Hey.
Oh, the speaker said his computer was out of power.
Let's wait for him now.
Let's take this time to think about any questions you have.
Hey, I just had one that I didn't quite understand.
Let me discuss it with you.
If I'm not mistaken.
He's generating those random instances.
Basically, it's completely independent and unrelated.
And then look at a distribution, right?
But in fact, for example, let's use a drinker.
I can do this this year.
For example, I generate a solution based on this guideline.
And then I'll do this this year.
And then see what happens.
And then adjust the next year's sequence according to this situation.
And then adjust the next year's sequence.
So, in fact, every instance should be.
It's going to be more refined.
Not irrelevant.
Right?
Oh, you mean those instances.
Uh, maybe this year's instance and next year's instance.
There should be some relationship.
For example, maybe the big ship always has 50% of the time.
The small ship always has 20% of the time.
Yeah, so you split it this year.
And then I feel like this.
Hey, let's take a look at the fairness of the last one.
The variance of each merchant ship.
And then use this as an indicator.
To adjust the next year's sequence.
It's a bit like your Newton's law.
The initial guess.
And then refine it to a more.
A process.
It's not going to be a bunch of guesses.
It's irrelevant.
Oh, yeah.
I think this is quite interesting.
You can ask him later.
Maybe his method.
If it's random.
His lower bound is not so good.
But he refined it to the maximum speed.
Much faster than others.
Isn't that amazing?
What you mean is.
If you have some understanding of his instance.
You know.
What does the job look like?
There should be a better solution.
Yeah.
I think this seems to have two questions.
That is.
One question is.
This year's solution.
And then.
And then look at the difference.
How much to adjust.
Is this question going to be refined?
It's a question in itself.
Oh, expert.
I never thought about it.
Is it going to be refined?
It's a question in itself.
Because if this question is.
Is a continuous.
Continuous function optimization.
It's usually refined, but.
Continuous plus smooth.
Some of the conditions will be refined.
But.
Because his optimization seems to be separated.
Then not continuous.
So it's hard to say if it will be refined.
Oh.
Hi.
Hi.
So is there a slide?
I can't hear him.
No, he has no sound.
Hello Xiaojie.
Xiaojie is still there.
Can you hear me?
Yes.
But we can't see you.
Screen.
And people.
Hello.
Hello.
Hey.
Sorry.
I'm back.
Give me 20 seconds.
Got it.
I'm so sorry.
I.
I just found out.
I forgot to put.
I just forgot to put the pen.
Bring the power line.
So I changed the computer in a hurry.
Okay, in short.
We just finished talking like that.
Thank you all.
Clap your hands.
It's a little funny.
I'll just sum it up.
In short, as I just said.
Basically, this Fairness research.
It sounds like it makes sense.
But in fact.
There are not many people who have studied.
Most of the research.
Are maximizing.
Overall effect.
So for this so-called job.
You love him and hate him.
Or between this agent.
Discuss fairness issues with each other.
In fact, there is little discussion.
This question also has a certain discussion value.
After all, he is NP-hard.
So the good algorithm.
Or the theoretical value of the algorithm.
It can also be discussed.
Then we all did these things.
In fact, it's not very good.
But it's done anyway.
It's probably like this.
Okay, thank you all.
Let's thank the speaker again.
OK.
There were some questions just now.
Yes.
Let me ask.
Let me ask first.
Oh.
My question is like this.
You just said.
Although you can.
There are some ways you can get.
Upper bound 1.33.
Then the lower bound.
For example, there are some lower bound.
If you generate a lot of.
Random instance.
You can look at a distribution.
Then say this is the lower bound.
For example.
This example.
For example.
I use such a guideline today.
To distribute.
Then everyone runs like this this year.
But I can see the results of this year.
As an index.
To adjust how to arrange next year.
and so.
I actually have a way.
In this way.
Keep going to a better solution.
Not every year.
What is the difference between each method?
What I just said.
It sounds like.
The difference between theoretical research.
Can I hear it like this?
Can you hear it?
Thank you.
That is to say.
We forgot what we just said.
In short.
This is a problem that needs to be solved.
There are a bunch of ships coming.
Then we have to run.
Then we have to sign them.
We want to make our goal as good as possible.
Of course you can.
Every year.
Your algorithm will make some adjustments.
The algorithm must be able to let you adjust.
Then you have some parameters.
It will do some settings.
This is OK.
So what you just said is definitely no problem.
You can make adjustments according to the change in the environment and the situation.
Then make adjustments.
In theory.
Let's think about an algorithm.
Its performance guarantee is two things.
That is.
I'll give you 1,000 ships today.
100 ships.
You use any algorithm to line up.
As long as it's not the best solution.
You don't know how far you are from the best solution.
Because you don't even know how much the best solution is.
Right?
So you line up.
Some people don't like it.
But in short, you don't know how far you are from the best solution.
OK.
The theoretical nature of the algorithm.
What's that?
He's telling us.
Our algorithm.
How far can our algorithm be from the best solution?
How far is it?
So this is two things.
In fact, as long as we line up the solution.
Everyone can accept.
Everyone thinks it's OK.
That's just in theory.
Everyone can know further.
How far are we from the best solution?
That's about it.
OK.
Thank you.
Thank you.
Are there any other questions?
Let me ask you a question.
I joined later.
I heard that there is a requirement.
That is to say.
This algorithm has to be easy to explain.
Is there any specific quantifier?
What kind of algorithm is easy to explain?
Or what kind of algorithm is not easy to explain?
The specific quantification.
As far as I know, there should be no.
Because the explanation is for people to hear.
The so-called people can not accept this kind of explanation.
I don't have anything.
People can accept within 15 seconds.
It's called good.
Then it's not good for more than 15 seconds.
This kind of 15-second quantification.
That's probably the only thing I can say.
Our algorithm.
First of all.
Why is it in some cases.
Good performance, bad performance.
To make sense.
Then why did he give this job to you?
Instead of giving it to him.
To be able to say.
The weaknesses of the algorithm.
That's it.
So it's still a straightforward.
Explanation method.
There is no so-called indicator.
Explainable indicator.
Basically, there should be no.
I'll just say it again.
It sounds like this.
There may be two.
Indicators in different directions.
One is.
Uh.
The algorithm has to explain.
Why is this job given to A?
Not to B.
This thing itself.
It seems to correspond to.
Uh.
The algorithm itself is weak.
It can't be too complicated.
Maybe there are only two or three lines of weak.
It's called simple.
This is the first one.
Then the second one.
Uh.
It seems to be more like.
Uh.
Uh.
Or.
I'm not sure if it's the worst case.
But.
Or how would a certain case be divided?
Then this case.
To be simple enough.
Then.
Is it true that this algorithm is good or bad?
Is that what it means?
Hey, that's right.
Yes, it is.
Explainable includes.
Uh, you just talked about these different aspects.
Uh, that's why the algorithm does this.
Why in this step.
Give this job to that person.
Uh, this is an explanation.
And then.
Why less work or more work.
Or when the work is tight, the work is loose, etc.
Why in this situation.
Well done.
Yes, these two are the so-called explainable range.
That.
Uh, as I understand it.
If we are engineers.
The point of the engineer is to solve the problem.
So as long as the algorithm performs well.
Say again.
So the explanation may not be so important.
That's like now.
Deep learning.
Those neural networks, etc.
They're all accurate.
So far, people haven't been able to explain why they're so accurate.
Anyway, let's use it first.
The academic will slowly follow up from the explanatory aspect.
And then, oh, he's really so accurate.
There must be a reason.
That's why there's a way to copy it later.
So everyone will look for.
Explanation.
So the explanation of this kind of thing is also very important in academia.
So back to the question we just talked about.
Why is our question in.
Actually, it's also very important to explain.
It's just a special case.
It's because.
The object of our explanation is those.
The people in the back row.
They care about fairness.
A lot of times the care is not to be black box.
So this algorithm is for them.
They don't quite understand.
So I think it's a black box.
So you have to be able to explain when there's a dispute.
Why is it arranged like this?
It's probably like this.
But it's also.
These information methods.
Sometimes when you want to apply it in practice.
The problem is.
Uh.
Uh.
Can I ask you another question?
Okay.
Uh.
I remember when I was talking about the black box.
Yes.
There is an example.
Uh.
If I am the person who designed this algorithm.
Then I might.
I am a black box myself.
Then I will collude with some people.
Then this black box to them.
Especially cool or particularly bad.
Uh.
No one wants to be particularly bad and collude.
But.
But this is the design.
The black box.
Uh.
This can be explained.
It seems to be another concept.
Because.
Is there a collusion?
Or is there a black box?
Uh.
I think mathematically.
It seems to be more than this human brain.
Can accept.
Can the human brain accept this in 15 seconds?
This point can be more.
This.
To express in a mathematical way.
Or.
Or check if it meets such conditions.
I haven't thought of a specific way yet.
But I think.
Is there a collusion or is there a black box?
It seems to be easier.
Handled mathematically.
Uh.
That's pretty good, right?
Yes.
Okay.
I also want to ask a question.
Okay.
Uh.
You have this algorithm now.
What I want to ask is.
When it comes to food.
For example.
The question of the drinker.
You may be based on.
Data from the previous year.
You may know this ship.
This is the proportion of the ship.
How is it?
Your work.
What is the proportion of the workload?
How many big ships and how many small ships?
That is food.
Will be based on.
Because this is what I mean.
Your instance is not random.
That is food.
Will be based on such.
Is not random.
To design algorithms.
Of course.
That is.
For example, work to come.
He must have.
If Kaohsiung Harbor.
He came in the middle of the night.
Kaohsiung Harbor must be added.
So most ships.
Will come in during the day.
Then especially at 7 o'clock in the morning.
Will come at 8 o'clock in the morning.
More than a hundred a day.
Because most of the ships.
He will be out at 5 or 6 o'clock.
So.
You will definitely consider your work.
They are not random.
Consider those patterns.
You already know that at 7 o'clock in the morning.
The workload is particularly large.
Logically speaking.
Of course, it is around 7 o'clock.
There are a lot of people on duty there.
So it is necessary to do the corresponding.
Of course.
Can it be done on food?
Another thing.
For example, the people of Kaohsiung Harbor.
They are in turn.
There are rules for their shifts.
One person is 24 hours in turn.
Then.
We also discussed with them.
There are a lot of people at 7 o'clock in the morning.
A little more people.
For some reason.
But this doesn't seem to be the point.
The point is that what you said is definitely.
Will go to deal with.
That food algorithm.
Naturally.
From the one we just talked about.
A simple algorithm to make some adjustments.
Probably like this.
OK.
I think everyone should be very easy to understand.
That is.
The algorithm of writing paper and the algorithm of food.
Obviously there will be differences.
When the algorithm is to be discussed in academia.
Must be.
Relatively abstract situation.
Relatively.
Relatively.
Simple algorithm to deal with.
Simple does not mean simple.
Just the situation of food.
There are two principles.
There will be 58 exceptions.
So the food algorithm.
Most of the time is to deal with those exceptions.
Then deal with those patterns you can see.
Since there will be a lot of people at this time.
Come in.
You put a few more people there at this time.
Probably like this.
Yeah, but these things are definitely done.
It's just that the requirements of food and mathematics.
Will be different.
You will also run some on food.
Is it simulating?
Will.
Because.
Now we are talking about food.
It has nothing to do with paper.
These work hours on food are random.
You said you want to send someone to the sea.
Bring a boat in.
The historical data allows you to estimate.
This is about 68 minutes.
But in fact it may be 78 minutes.
It is possible for 52 minutes.
In fact, it does have distribution.
Distribution will be received.
Who is the queen?
Who is the drinker?
The size of the ship.
The impact of eating and stewing.
So it's really time to do.
Food algorithm.
You must do simulation.
To be more reasonable.
To evaluate the good and bad of the algorithm.
That's right.
This sounds complicated.
I think so too.
If you talk about food.
You can talk about it again.
There are a lot of strange things.
For example.
According to the reason.
What time should the ship leave the port?
After the drinker arrived at the scene.
I found out that his ship was still on and off.
This is also very normal.
Or sometimes the ship will break down.
Then this.
Then the tower has already arranged.
This ship comes out first.
Then that ship goes in again.
Sometimes someone will be in line.
So it will be messy later.
That's right.
This is also at the airport.
Many times similar problems.
Oh yeah.
Airport.
That is.
There are people in the airport.
Then the plane takes off.
So the problem is quite similar.
Then this.
Airport.
There will be a lot of unexpected things.
Yeah.
Most of the time.
There will be all kinds of if else.
If something happens.
You do this and do that.
OK.
Does anyone have any questions?
Actually I still have a question.
But I want to ask at the end.
Because it doesn't matter.
If there is no question to ask.
Then let's thank Professor Kong first.
Wonderful speech.
Thank you all.
Happy youth.
Let's turn off the video first.
OK.
