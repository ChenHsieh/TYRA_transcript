1
00:00:00,000 --> 00:00:03,000
整理&字幕 由 Amara.org 社群提供的字幕

2
00:00:30,000 --> 00:00:33,000
整理&字幕 由 Amara.org 社群提供的字幕

3
00:01:00,000 --> 00:01:03,000
整理&字幕 由 Amara.org 社群提供的字幕

4
00:01:31,000 --> 00:01:34,000
主持人:「那我們這個時間就先交給這個耀嘉囉。」

5
00:01:35,000 --> 00:01:37,000
耀嘉:「OK,聽得到我嗎?」

6
00:01:37,000 --> 00:01:38,000
主持人:「可以。」

7
00:01:38,000 --> 00:01:39,000
耀嘉:「OK,好。」

8
00:01:39,000 --> 00:01:42,000
耀嘉:「好,那我就,這邊就開始。」

9
00:01:42,000 --> 00:01:45,000
耀嘉:「然後,呃,其實是通道資訊啦。」

10
00:01:45,000 --> 00:01:50,000
耀嘉:「它,通道資訊則是說,我在,比如說無線的傳輸。」

11
00:01:50,000 --> 00:01:58,000
耀嘉:「在做無線傳輸的時候,如果我事先能夠知道,呃,就是這個傳輸的效果好跟壞。」

12
00:01:58,000 --> 00:02:00,000
耀嘉:「或是我真的可以量化它的話。」

13
00:02:00,000 --> 00:02:04,000
耀嘉:「那我可以在傳送端的部分,就先事先做一些配置。」

14
00:02:04,000 --> 00:02:07,000
耀嘉:「然後,進一步提升我傳輸的效率。」

15
00:02:07,000 --> 00:02:11,000
耀嘉:「但如果今天這個資訊是,欸,是不是那麼準確的。」

16
00:02:11,000 --> 00:02:16,000
耀嘉:「呃,那這樣的話,對於我的傳輸效率會有什麼樣的影響。」

17
00:02:16,000 --> 00:02:19,000
耀嘉:「那希望可以講到今天那一步,呃,就是這一步啦。」

18
00:02:19,000 --> 00:02:24,000
耀嘉:「因為今天看,今天的,的,呃,有些人是我認識的。」

19
00:02:24,000 --> 00:02:27,000
耀嘉:「然後他們可能都有相關的通訊的背景。」

20
00:02:27,000 --> 00:02:31,000
耀嘉:「那,那,但是大部分人都不是做,都不是我們同行的。」

21
00:02:31,000 --> 00:02:35,000
耀嘉:「所以,就,呃,我看看能,能夠講多少,這樣子。」

22
00:02:35,000 --> 00:02:37,000
耀嘉:「OK,好。」

23
00:02:37,000 --> 00:02:40,000
耀嘉:「好,那今天我會主要是講這三個部分。」

24
00:02:40,000 --> 00:02:48,000
耀嘉:「第一個部分是我會先回顧,就是,當我們,呃,所謂的在受雜訊干擾的,的通道之下。」

25
00:02:48,000 --> 00:02:52,000
耀嘉:「然後我們怎麼,我們怎麼去,我們怎麼去做資料傳輸。」

26
00:02:52,000 --> 00:02:56,000
耀嘉:「然後,當然我們有一些,那個,基本的限制。」

27
00:02:56,000 --> 00:03:01,000
耀嘉:「譬如說,當然我希望我的傳輸的效率越高越好,速度越快越好。」

28
00:03:01,000 --> 00:03:04,000
耀嘉:「但是我同時不能讓傳的東西有錯。」

29
00:03:04,000 --> 00:03:06,000
耀嘉:「那我應該要怎麼,怎麼做。」

30
00:03:06,000 --> 00:03:09,000
耀嘉:「那,呃,這個其實在1948年的Shannon,Plot Shannon。」

31
00:03:09,000 --> 00:03:11,000
耀嘉:「其實他就已經研究過這個問題了。」

32
00:03:11,000 --> 00:03:16,000
耀嘉:「然後我們也,他有一些,呃,有一些,基本上這個,呃,他有一些結果。」

33
00:03:16,000 --> 00:03:18,000
耀嘉:「一些不錯的結果,我們要來做介紹。」

34
00:03:18,000 --> 00:03:24,000
耀嘉:「然後第二個部分是,我會簡單帶過一些,就是目前,呃,對於簡單的網路。」

35
00:03:24,000 --> 00:03:29,000
耀嘉:「譬如說像是,什麼,呃,像是廣播網路,Broadcast Channel。」

36
00:03:29,000 --> 00:03:32,000
耀嘉:「像是干擾網路,Interference Channel,這種簡單的網路。」

37
00:03:32,000 --> 00:03:39,000
耀嘉:「他們有目前的一些,呃,對於這種傳輸問題的,呃,目前的解決的現況。」

38
00:03:39,000 --> 00:03:42,000
耀嘉:「還有哪些問題解了,哪些問題還沒有解。」

39
00:03:42,000 --> 00:03:47,000
耀嘉:「然後在沒有解的狀況下,我要怎麼去處理,怎麼去get around with it。」

40
00:03:47,000 --> 00:03:50,000
耀嘉:「然後最後的部分是,其實是比較偏向我的研究。」

41
00:03:50,000 --> 00:04:04,000
耀嘉:「如果今天我在傳送端,其實不知道我中間的這些通道,這些,這些連結是怎麼,怎麼是,呃,呃,的詳細的資訊的話。」

42
00:04:04,000 --> 00:04:07,000
耀嘉:「那會對我的傳輸效果有什麼根本上的影響。」

43
00:04:08,000 --> 00:04:10,000
耀嘉:「那首先是第一個部分。」

44
00:04:10,000 --> 00:04:17,000
耀嘉:「那,呃,其實基本上,呃,通訊的通,在我們在做通訊的時候,通道永遠都是,都是noisy的。」

45
00:04:17,000 --> 00:04:20,000
耀嘉:「都是,都是受雜訊影響或干擾的。」

46
00:04:20,000 --> 00:04:23,000
耀嘉:「在有線的通訊也是,在無線的通訊也是。」

47
00:04:23,000 --> 00:04:25,000
耀嘉:「而且無線通訊的環境更複雜。」

48
00:04:25,000 --> 00:04:32,000
耀嘉:「因為那個所謂的multipath的效應啊,我們,呃,就是信號會受到扭曲。」

49
00:04:32,000 --> 00:04:41,000
耀嘉:「除了雜訊之外,還有,還有,還有這種就是扭曲,使得我在某些瞬間,順時的狀況,我的訊號的強度其實是非常低的。」

50
00:04:41,000 --> 00:04:45,000
耀嘉:「那我們今天先不討論這種複雜的狀況,我們繼續討論上面那個狀況。」

51
00:04:45,000 --> 00:04:51,000
耀嘉:「就是在有線的通訊之下,我信號受到雜訊的影響。」

52
00:04:51,000 --> 00:04:59,000
耀嘉:「那我的接收端在,在,在去接收這些資訊的時候,難免都會有錯,都會解錯資料。」

53
00:05:00,000 --> 00:05:12,000
耀嘉:「那通常常見的模型,常見作為分析的模型,呃,包括有,呃,常見作為分析的模型,大概有,有下面這兩個。」

54
00:05:12,000 --> 00:05:32,000
耀嘉:「就是,呃,AWGN Channel,Additive Wide Gaussian Noise Channel,那基本上它講的是說,我,我輸入X1、X2到Xn,然後呢,就是,然後我通道的輸出是Y1、Y2到Yn,然後輸出是X,呃,我送的東西加上一個常在分布的隨機變數。」

55
00:05:32,000 --> 00:05:44,000
耀嘉:「它就是一個隨機變數,就是一個雜訊,但其實這個問題還是很複雜,各位我們已經把問題弄到這麼簡單了,其實它還是很複雜,所以我們就是進一步考慮,就是更簡單的Binary Symmetric Channel。」

56
00:05:44,000 --> 00:05:58,000
耀嘉:「它只是說,我今天傳,呃,輸入是X1到Xn,然後接收,呃,在接收端我們收到Y1到Yn,然後我們限制X1,每一個,每一個X、每一個Y都是只有取之0或者是1。」

57
00:05:58,000 --> 00:06:20,000
耀嘉:「好,那中間通道呢,它怎麼,如果今天中間通道它怎麼,怎麼改變這些X跟X呢?它有可能,比如說送進X1之後,它有,假設它是0,那它就有一定的機率P被翻成1,那今天,然後如果它今天被翻成1的話,那這個Y1看到的就是1,那如果今天它沒有變成1的話,那當然就還是0。」

58
00:06:20,000 --> 00:06:49,980
耀嘉:「那現在就是問題就是說,現在這個問題就是說,好,那如果我真的,呃,用這樣,假設我們通道簡化成這個樣子,呃,能夠餵進去的只有,只是0或者是1,但中間有一定的機率某些Bit會被,某些輸入會被翻,會被翻動,會被改變的話,那我要怎麼做傳輸呢?我要怎麼做訊息的傳輸呢?那其中一個方法就是,我就直接傳0或者是1,就是,然後我就完全不做任何的編碼。」

59
00:06:50,000 --> 00:07:17,980
耀嘉:「那這樣當然會有,它的那個error rate當然,是它的錯誤率當然就是,呃,它就是P這樣子,因為它有給定一個X1,它被翻動的機率是P,所以它錯誤率就是P。有沒有更好的方法呢?當然是有,我們做一些基本的保護裝置,保護的架構,呃,比如說我,呃,我要送0的時候,我就傳3次,我要送1的時候,我就傳3次,那我在接收端收的時候,我們用所謂的多數學的方式來做,

60
00:07:18,200 --> 00:07:47,160
那基本的,用高中數學可以算出這個error rate一定會比較低,大概是長成這個樣子,但同時,我為了傳一個bit,我用了3次通道,所以呢,我的data rate,就是我的資料傳輸的速度就會降低,那當然我去增加我的重複的次數,一定會降低我的error rate,但代價是什麼?代價是我data rate會降低,而且當我,呃,當我的通道次數增加的時候,

61
00:07:47,260 --> 00:08:08,180
它會,它的那個data rate就會降到0,那其實這不是我要的結果,因為,呃,我為了要保護它,然後我就傳這麼多次,結果我反而讓我的data rate變低了,那接下來我的問題就是說,呃,有沒有可能同時維持data rate的狀況,比如data rate不是0的狀況,降低錯誤率呢?

62
00:08:08,180 --> 00:08:09,180
然後呢,這裡的話就是,呃,這是一個,算是大哉問吧,就是大家可以想,馬上可以想得到的問題,但進一步,那學長的第一個貢獻就是,我去,他去進一步釐清這個問題是怎麼樣,第一個就是,呃,他進一步去拆解這個,這個,這個問題本身啊,第一個部分的話,我們就加一些條件,呃,第一個問題是,我們就,呃,我們就不限制,就是在編碼或解碼上,比如我就做對於x,我對於x沒有做,呃,他做任何的計算,呃,我對於x沒有做,呃,他做任何的計算,呃,我對於x沒有做,呃,他做任何的計算,呃,我對於x沒有做,呃,他做任何的計算,

63
00:08:38,180 --> 00:09:08,140
呃,我對於y做任何的計算,都沒有什麼computing complexity的問題,管他是不是np-complete,假設我有一台超級無敵計算機,他可以瞬間算好,然後呢,我們沒有限制通道的使用量,然後呢,然後就進一步去想data,這些data bits,其實他可能被,他其實可以被,呃,他可以借一張表,就是ok,這張表就是在,像是右邊這張表,他傳這些bit,傳這些data,其實本質上我傳的是什麼,傳的是哪一個message,

64
00:09:08,140 --> 00:09:38,140
從1編號到m,那所以,呃,這本問題的本質變成是說,我傳,比如說我要傳第10個message,好了,那我要怎麼去設計這個傳輸的方式,讓在這邊,在接收端的這邊,我能夠正確的被解回來,然後呢,再來就是ok,再來就是那個rate,rate的定義方式,像我剛剛講的,呃,一次通,呃,就是呃,你你在這麼多的通道,n次通道的使用量的情況下,呃,你在這麼多的通道,n次通道的使用量的情況下,呃,你在這麼多的通道,n次通道的使用量的情況下,呃,你在這麼多的通道,n次通道的使用量的情況下,呃,你在這麼多的通道,n次通道的使

65
00:09:38,460 --> 00:10:08,120
你到底送了多少的bit,ok,這邊有m個bit,所以其實你可以用log12為你的m來表示它,所以總共有log12的bit這麼多,所以你可以得到一個基本的,就是這個基本的,就是高度數學可以得到的等式,就是m其實就可以把它寫成2的nr次方,n是通道的使用量,然後r是那個傳輸速度,好,所以其實我們以後就是習慣在,呃,文線上,或是課本上,或是我們都習慣用了這個2的n的r次方來表示,

66
00:10:08,520 --> 00:10:35,960
呃,訊息的數量,然後呢,所以他跟你講說,我要讓錯誤率越小越好,他只能是說,我在接收端,我傳了一個message,在傳送端,那接收端收的時候,我要去,我要去設計一個解碼器,解碼器的本質就是猜,那猜到底是哪一個message被送,我想要,那這個error是說,我猜錯message了,比如說我傳第10個,你可能猜成第1萬個,那就是發生錯誤的,錯誤的事件,

67
00:10:36,560 --> 00:11:05,040
那我們想讓這個事件的機率越小越好,那但是呢,我一定要是,呃,已經是,比如說事件設定好,比如說10的10次,-10次方,10的-100次方,等等的,這種,這種,這種機率,ok,所以,所以就把這些限制條件就轉成像這樣子的一個傳輸的架構,我左邊,左下角有一個message,這麼多,然後我,我可以,比如說他說我的,我說他傳這麼多bit,

68
00:11:05,040 --> 00:11:35,000
所以本質上其實我是傳某一個message,然後呢,他說,他其實說,ok,我應該把這個message經過某一種方法,比如說查表,我們建一個那個碼書,codebook,每一個message對應到某一組code word,然後呢,我把用查表的方式,呃,把message訊息編成code word,然後呢,再送到這個channel裡面,某些bit在y的,呃,然後收到y,y的某些bit可能會被翻動,

69
00:11:35,640 --> 00:11:53,800
那我們在經由解碼器,解碼器假設我知道,大家都知道codebook長什麼樣,然後我們就可以解出我們真正想要的那個message,ok,所以現在問題就變成說,我們能不能去設計這樣子的一個coding scheme,那coding scheme是什麼呢?就是編碼模式,編碼的架構,編碼架構是什麼呢?

70
00:11:53,800 --> 00:12:18,220
包包含了就是codebook,encoder跟book其實一樣,原來就是查表而已,還有呢,我的decoder,我的解碼器,我的codebook要求是,是不是能夠,是他的code rate,就是他的傳輸速度是不是不是為0,或是不是一個很小的值,還有呢,我的解碼,我的解碼錯誤呢,他是可以被控制在一個很小的值。

71
00:12:19,220 --> 00:12:44,840
好,那所以這邊就是,所以現在就是我們就把那個問題架構formulate成這個樣子,就是我們有編碼器,解碼器,然後呢,我們要目的是要把這個message傳到另外一端,然後這邊我要讓這個mhat,就是接收端猜到的m,猜到的message,發生錯誤的機率越小越好。

72
00:12:44,840 --> 00:13:11,300
或者是在某一個,錯誤發生的機率是在某一個值下面這樣子,ok,那這個檔案,所以說我剛剛其實已經爆雷了,就是這個其實是可以做到,要不然其實我就演不下去了嘛,我就講不下去了,然後呢,他是,然後呢,他這跟,然後呢,這是Shannon在1948年的,算是他最有名的貢獻之一啦。

73
00:13:15,680 --> 00:13:44,820
那他是,他的講法,他是說,好,我們有一個magic number,一個神奇的數據,數字叫做channel capacity,叫做C,然後呢,他是一個好像看起來很複雜的東西,不管他怎麼翻,就是我們可以算出來的東西,然後呢,他單位是什麼,單位是我每用一次通道,我可以傳多少information bit過去,他是跟你講說,當如果你今天設定說我的code rate,就是我傳輸的速度,小於這個神奇的數字的話,

74
00:13:44,840 --> 00:14:05,760
那我一定可以找得到一個,一定可以找得到一組coding scheme,包含什麼codebook加上解碼器,然後呢,但是這個n可能要很大,讓我的錯誤率,就是我的那個效率,就是那個錯誤率可以拉到我要的那個,那個支持的負100次方的水平。

75
00:14:06,760 --> 00:14:26,860
但如果今天你,如果你今天把你的那個傳輸的速度設得太快,設得太高,讓他大過channel capacity,這個C的這個神奇的數字的話,那問題就來了,如果你今天,今天,那這樣的話,問題,工程上的問題就來了,

76
00:14:26,860 --> 00:14:46,860
因為有可能你對所有的n,對所有的,不管你找遍所有的可能的方法,你都沒辦法讓我的那個錯誤率能夠降到你要的這個水平之下,比如說0.5,0.5是10%,10%可能是一個很ok,很loose的數字,

77
00:14:46,860 --> 00:15:15,360
data可能可以,但是可能你開始降到10的負100次方的時候,呃,10的負6次方,10的負7次方的時候,就會發現,欸,你就找不到,不管你n用多少,你就找不到這樣子的編碼方式,ok,所以這個就是那個,這叫noisy channel coding theorem,然後他就把,我們就把這個在我們這個工程,通訊工程界,就把這樣的架構,就包含就是這樣子轉換的方式,編碼保護的方式叫做channel coding,通道編碼。

78
00:15:16,860 --> 00:15:46,840
ok,如果你這邊有任何的問題,大家可以提出來,因為其實我應該是,對,應該就是像主持人講,就是蠻這邊真的是蠻數學的,然後呃,我從以前做就是比較工程的問題,然後轉到比較理論問題來的時候,其實也是struggle很長一段時間,然後才搞清楚,哦,原來就是呃,就是就是他們的想法,就是做理論想法跟做做做實際問題,在問工程問題的人,呃,每天在碰第一線,碰工程問題的人的想法是完全不一樣的。

79
00:15:47,860 --> 00:16:15,360
需要一點時間轉換,ok,好,所以這邊就扯到一個神奇的數字,就是叫做channel capacity,然後他是這樣,這個東西,那這個東西是什麼呢?這個東西其實,呃,還有一個數學定義,他就是,呃,好像很複雜,寫成h of y 減掉h of x given,這個是,這個一個bar叫given,就跟那個機率的條件機率一樣,given x 這樣子,然後同時你可以證明說,ok,如果你把xy互換,其實也是可以,那這是什麼東西呢?這個就是牽扯到h是什麼呢?

80
00:16:15,360 --> 00:16:45,340
h就是所謂的entropy,那如果你是念物理的,你一定會知道什麼叫做entropy,如果你是念化學的,你一定知道什麼叫做entropy,他基本上就是衡量一個系統的亂度是多少,那這邊的,這邊的entropy就跟那邊的不太一樣,這邊的entropy的定義是說,哦,好,如果今天,本來他衡量的是亂度,但是他講的是不一樣的事情,他今天是講的是說,如果今天的x是,呃,取值是0跟1的話,那,那我們可以去,比如說我們去規定,比如說,x是1的只有機率是這麼多,

81
00:16:45,340 --> 00:17:14,720
然後p of x,呃,px of e,然後乘上log也有你的,呃,p of x,不對,呃,p of x 1分之1也這麼多,然後0把0帶進去,算出來的值就是x的entropy,x的隨機變數的entropy,好,那他的意思其實就是x的不確定性,然後我們是用bit來,呃,不確定性的度量,然後我們是用bit來衡量的,他只是說,如果你需要知道x是什麼,因為x是隨機變數,

82
00:17:14,940 --> 00:17:40,780
你在做實驗之前,你是不知道它值是多少的,但你做了實驗之後,ok,你需要用多少bit的數目才能夠代表這個實驗結果,ok,也就是說,呃,你有多少,代表說你有,呃,你有,你,對,就大概是這樣子,然後他其實是有被列在就是,就是有個網路上有個密碼,就是他是19 equations that change the world,其中一個是薛丁格方程,

83
00:17:40,780 --> 00:18:08,080
然後,但量表裡面有一個就是information entropy,好,那也有這個東西,我們由這個比較他的詮釋之後,他entropy指的是,呃,我們對x的不確定性,or in terms of bits,或者是我們需要知道x的數值是多少,我們需要做,需要知道多少的bit,那我們來看這個東西是什麼,i of x分號y,他呃,他名稱叫做mutual information,

84
00:18:08,580 --> 00:18:37,780
他從第二個equation等式來看,你可以看到就是說,他其實是x的不確定性減掉,給定y之後,x還剩下多少不確定性,ok,那他意思其實就是什麼呢?他其實就是,如果你知道,呃,y的情況下,呃,你知道y的情況下,你有多少bit其實是,呃,你,你可以知道x是多少bit,那所以其實某種程度上,其實這就是我們要的東西,就是直觀意義上來看,其實就是,呃,

85
00:18:37,780 --> 00:19:07,760
我收到,在接收端收到y,那我不知道x是多少,那那mutual information其實給我的是,呃,x就是,呃,給定y的情況下,我知道x有多少東西,我知道x的,x的值是什麼,的in terms of bits這樣子,ok,那呃,所以直觀上來講,好,這好像是我們要的東西,但是實際上的證明非常的,非常的不簡單,然後因為這個證明其實也,

86
00:19:07,760 --> 00:19:37,740
也開啟了很多,完全一個新的領域叫做,電信工程下面有個新的領域叫做消息理論,那那這種證明其實通常,通常我們知道在我們這領域證明通通分兩個部分,第一個部分就是所謂的converse part,他要證明說,ok,我的code的那個傳輸速度大於c是不可能的,那第二個部分是achievability part,就是可以達到達到的那個種的的部分,那他只是說,呃,我,我要實際上去找一個編碼,

87
00:19:37,760 --> 00:20:07,740
方式讓這個編碼方式能夠傳用這麼高的速率傳,你接近capacity的速度,速率去傳,ok,ok,那當然我們在在傳的過程中,我們要,呃,我們但是我們要先指定我的錯誤率,譬如說十得負一百次吧,然後呢,我們要找到這樣子的coding scheme,然後,然後當然n可以是任意值,他可能要以一個bit才能夠,才能夠,才能夠編碼完成這樣子,

88
00:20:08,760 --> 00:20:34,760
ok,好,那不好意思,我可以問個問題嗎?哎,請說,這是呃,因為我完全是不懂,所以呃,就是我想要可不可以請你舉個例子,就譬如說,假設我知道,假設我有一個傳輸的方法,然後呢,我,我接到y以後,我完全確定x是多少,然後那i會是多少,i會是零嗎?

89
00:20:35,760 --> 00:21:00,200
i的話,ok,如果你知道,比如說像這樣這個好了,呃,呃,如果你說,你知道接到x之後,你完全知道x是多少,對不對?這我的問題其實就是,你有一個ideal的channel,對,完全沒有noise,對,對,那你你接到y以後,你就完全知道x是多少嗎?對,對,那在下面那個probability應該都是零吧,是嗎?

90
00:21:00,280 --> 00:21:28,040
呃,不是不是,ok,我大概知道你的意思了,如果是這樣子的話,那就要跟呃,x本身的的x本身,就是ok,他他意思,他如果是你用這樣的方式的話,我可以可以這樣子回答你,就是如果你知道y,那你對x,那那如果那假設是noise的channel的話,x其實是,你知道y接到x,所以你對x的不確定性,接到y之後,對x的不確定性就是零,所以這一項就是零。

91
00:21:29,000 --> 00:21:47,120
所以呢,這個mutual information,mutual information就等於x的entropy,就是等於是x的呃,等於說,你該想的是,x有多少個bit,比如說,如果用這個公式來衡量的話,你比如說,你編碼的方式是用,比如說,呃,有50%的機率是1,50%的機率是0。

92
00:21:48,120 --> 00:22:17,020
那這樣子的話,你如果你可以把這個呃,這個證明,把把這樣的數據帶進去算,h of x,得到的答案會是1,ok,代表說什麼呢,代表說什麼呢,嗯,p是二分之一嗎,二分之一,對,ok,二分之一,然後,然後log也要為你的二分之一分之一是1,這個值是1,所以,所以他有兩個二分之一嘛,對不對,哦,ok,所以加起來是1,ok,對,所以這個值i,

93
00:22:17,020 --> 00:22:46,920
所以future information就是,future information就是1,代表說什麼呢,代表說,我的傳輸的速度可以是1,一個bit per channel use,ok,所以channel capacity就會是1,然後最大的r也是1,對,ok,對,而且你可以很輕,你可以很容易的證明這件事情,為什麼呢,因為是channel是noiseless,所以你不管你傳什麼,他就說,呃,應該說我收到的東西跟傳的東西一模一樣,嗯,對不對,那就等於是沒有這個channel存在,

94
00:22:47,020 --> 00:23:17,020
我就直接去拿,拿我的那個,那我知道這個,好,好,這個base case,我現在懂了,ok,好,對,好好,那,那,那我應該要給一個,我今天其實,我在講稿裡面有寫一個例子,可是我忘了講,ok,對,感覺需要澄清一下,就是,就是剛剛的那個例子,不是說,嗯,嗯,要怎麼說,noiseless的狀況之下,future information就always是1,是剛剛那個例子是1,哦,對對對,跟你的編碼方式有關嘛,對,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,ok,

95
00:23:17,020 --> 00:23:46,020
跟在我的x,比如說,如果今天,呃,我傳的x,呃,有10%是,呃,比如說像,呃,另外幾段例子好了,假設我的x啊,編碼方式有100%都是1,0%都是0,代表說我的,我傳的東西全部都是1嘛,對不對,對,對,沒錯吧,對不對,這是一個另外一個極端的例子,那這樣子的話,你可以算出來說,就是,entropy其實是0,

96
00:23:48,020 --> 00:24:14,020
因為1從上,你根本就沒傳任何資訊出去,對,沒錯,那這個東西是0,所以,所以代表說,ok,你想要從那個那個傳送端拿資訊來的時候,你發現他其實根本沒有傳任何東西,ok,因為他永遠都是送1出來這樣子,了解,ok,好,然後呢,接下來就是要問說,就是,那我要怎麼去去達到這件事情,

97
00:24:14,020 --> 00:24:44,020
因為其實,因為我一直在想說,這個東西到底要不要講,因為其實他證明的過程有一點複雜,我們先講那個converse的部分,我們就不用講,因為這個更複雜,那個是完全是另外一個世界的問題,好,但是我們來想,從工程師的觀點上來看,我要怎麼做到這件事情,他說,呃,我可以用這麼快的速度去編碼,呃,去傳資訊,那我要實際上怎麼做這件事情,那我這邊嘗試用一些簡單的例子去講這個,因為他的,我們來看看,我們來試試看能不能,能不能,能不能在,呃,在,呃,在,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,�

98
00:24:44,020 --> 00:25:13,860
在很短的時間內講完,講清楚這樣子,ok,所以目前目標就是什麼呢?我要去找一個codebook,然後呢?他的,他的,他的,那個編碼的速度呢?是大概是,或是他的傳輸速度是很接近c,然後呢?還有一個decoder,還有一個編碼器,ok,說要找這兩個東西,那我們假設,我們輸入是,就是0.出入,呃,exit,exit1的機率是等於1的時候是0.5,等於0的時候也是0.5

99
00:25:14,380 --> 00:25:30,860
然後呢?通道,這個通道啊,翻動的機率是0.1,就是這邊我輸入0的話,有0,10%的機率會被翻成1,90%的機率,90%的機率會翻,還是維持原樣這樣子,ok,好,那實際上他們怎麼想這個問題呢?

100
00:25:30,860 --> 00:26:00,460
他其實是想說,好,那我就隨便亂產生那個,我有一個random number generator,我就隨便亂產生0跟1,總共產生n個,那我用這個這些點代表說,隨便產生一組數值的結果,那我用這個大圈圈代表說,所有可能的狀況,所以這些點其實都是,呃,我只是集中幾個例子而已,好,根據大數法則,我用出現機率,x啊,它的出現機率,呃,出現1的機率是0.5,

101
00:26:00,700 --> 00:26:28,780
出現0的機率也是0.5,所以代表說什麼呢?我可以找到一些,ok,我可以找到一些,比如說紅色的點,我可以找到一些code,它大概有50%的成分,大概一半是1,另外一半是0,像紅色code就是這樣子,綠色code也是這樣,就是它前面一半是1,後面一半是0,像這個綠色的也是一樣,前面一半是0,後面一半是1,ok,那大數法則跟我們講說,

102
00:26:29,220 --> 00:26:57,860
我隨機產生一組code word,它會落在這個藍色的這個集合裡面,我們把這個東西叫做typical set,會落在這個集合裡面,出現的機率是1,為什麼呢?比如說像這個,呃,比如說像這個,全部都是1的狀況好了,那如果我今天,雖然,全部都是1的狀況好了,那這個狀況很不可能發生嘛,對不對,對不對,根據大數法則,

103
00:26:57,860 --> 00:27:27,820
你要從全部產生,你要丟銅板丟連續一萬次都是正面狀況,基本上0嘛,如果全部都是0的機率呢,都出現反面的機率,也都是接近0嘛,所以只有在,呃,所以這個東西並不會落在這個藍色這個區域裡面,這個藍色區域是收集了所有,那個,50%是1,50%是0的所有的sequence,所有的那個code word這樣子,好,如果我今天選了一個紅色的code word,

104
00:27:27,860 --> 00:27:57,340
然後拿著拿去讓他去傳,那會發生什麼事?那這個通道其實在做的事情其實是什麼呢?就是把這些101010,然後呢,我去通過通道的時候,這些10會隨機的翻動,有些可能會不變,有些可能會翻動,那有百分之,大概有百分之十的,百分之十的bit可能會被翻動,百分之九十的機率不會,呃,九十的bit不會被翻動,所以這是這個通道的特性,好,那等於在數學上等於什麼?

105
00:27:57,340 --> 00:28:22,340
呃,其實我就是,呃,原本的東西加上一個,呃,sequence,就是我就是component外相加,然後呢,這個Zn是什麼呢?這個Zn其實有百分之十都是1,百分之九十是0,ok,然後,那,那這個也是很有可能,那這個也根據大數法則,這個是很有可能會發生的事情,而且發生的機率很接近1,好,那會發生什麼結果呢?

106
00:28:22,340 --> 00:28:51,580
會發現就是,欸,我的紅色經過,呃,Z的擾動之後,它可能是這個紅色小圈裡面的紅色點的任意一個,ok,然後我們把這樣子的這個東西,呃,每一個點其實都是一個sequence,N,長度為N的sequence,0,1的sequence,那具體而言,哪,有百分之哪,哪些,哪些被翻動,其實我們不知道,我們就把它全部收集在這裡面好了,那我們把這個集合叫做,給定,呃,我傳101010的狀況下,

107
00:28:51,580 --> 00:29:21,260
我收到的Y,呃,是有哪些這樣子,然後它本,它是什麼呢?它是101010加上那個所有可能,呃,所有,呃,發生機率很高的擾動的那個結果,比如說裡面有前百分之十都是1,後面百分之十是0,那我們就是放在這個,這個集合裡面,然後呢,這個,然後呢,這個紅色點就是,比如說我們這個點好了,這個點就是,剛才那個101010加上前面百分之十是1,後面百分之十是0,

108
00:29:21,600 --> 00:29:30,560
呃,那個結果這樣子,ok,好,同樣,同樣的東西,那這些東西是,都是很有可能發生,因為根據大數法則,那同樣的道理我們可以怎樣呢?

109
00:29:30,560 --> 00:29:45,180
我們,呃,可以去看說,ok,其實,呃,你剛剛講的那個小圈,其實落在這個紅色大圈裡面,紅色大圈它本身也有那個,那個它本身是channel output,channel輸出的的的的Y,

110
00:29:45,180 --> 00:29:57,040
它也,我們也可以定義就是它所謂的typical set,我們可以算出來說,ok,Y其實也有50%是1,50%是0,那我們就收集那些有一半是1,有一半是0的那些sequence,就把它收集在這裡面。

111
00:29:57,460 --> 00:30:07,320
然後呢,我們把這些綠點,這個綠點,這個綠點,這個綠點,這個綠點,這四個綠點,分別透過這樣子的方式傳,同樣的我們都可以收到這些,

112
00:30:07,840 --> 00:30:24,420
比如說最左邊那個綠點,它收到的就是,它有可能就是這個綠色小圓圈裡面,最上面這個收到的是這個,右邊的是最右邊的,最下面的是收到最下面的,ok,好,那接下來我要設計這個解碼器,

113
00:30:24,480 --> 00:30:39,720
所以我們可以觀察說,如果今天我這個選的點很少的話,比如說我只選這五個點好了,那其實它被映射過來之後,我在Y上面看到說,可能其實它們都不會互相覆蓋嘛,其實都是獨立的,都是disjoint。

114
00:30:40,740 --> 00:30:47,780
那代表說什麼呢?我只要它紅色的點出現在紅色這個區域裡面,我就可以馬上判定,哦,它其實傳的是這個。

115
00:30:48,780 --> 00:31:02,240
左邊綠色的這個點,它如果送到這邊,我如果觀察到它是這裡面的其中一個的話,我可以馬上知道它傳的是這個,ok,所以我們可以設計解碼器,設計解碼器是什麼呢?

116
00:31:03,240 --> 00:31:22,880
我去看看這個Y,就是我收到的這些sequence,看看是在哪一個這個集合裡面,如果它在這個集合裡面的話,我就把Y解碼成原本對應的那個X。

117
00:31:22,880 --> 00:31:41,540
比如說,如果它Y是在紅色的話,我就解碼成紅色的,如果它Y是在左上角的這個集合的話,我就解碼成左上角的這個,ok,好,這是最數學的部分,我們可以去計算說,到底有多少個?

118
00:31:42,240 --> 00:32:04,080
呃……ok,應該是這樣講,就是說,我們今天設計解碼器是這樣子,那我剛剛講過說,如果它們沒有互相這些小集合、小圈圈都沒有重疊的話,那我就可以成功的解碼,而且沒有錯誤嘛,對不對,或是錯誤率,我就說我沒有錯誤嘛。

119
00:32:04,160 --> 00:32:32,740
但如果今天有一點點,允許一點點重疊的話,那我們可以讓錯誤率控制在我們要的那個threshold,我們要的10的負6次方,10的負100次方之下,好,那現在問題是說,ok,我們不能去選太多這些點,比如說我們剛剛選的五個點,它就已經讓這個紅色裡面這麼多擁擠的小圈圈了,如果我們再選再多幾個的話,那這些小圈圈其實就會重疊了。

120
00:32:33,580 --> 00:32:42,880
只要有出現大面積重疊的小圈圈,我們就會出現解碼錯誤,而且這錯誤還很高,ok,我們要盡量避免這種狀況發生。

121
00:32:42,880 --> 00:33:09,280
所以我們怎麼看呢?我們去看看藍色圈圈裡面到底大概有多少個code word在裡面,我們把這個藍色圈圈叫做Tx,然後我們就用一個bar來表示它的絕對值數量,然後你可以算出它的數量其實是大概2的n次方乘上h of x,就是x的entropy。

122
00:33:09,780 --> 00:33:37,380
那它詳細的推導就是,其實很簡單啦,就是你去想說,如果我隨機產生編碼的話,我要怎麼抽到紅色這個碼,那它算出來的機率是大概這麼多,這是高中數學可以算出來的,然後呢,經過高中數學的轉換,換把這個Tx丟到次方上面的話,你可以算出,ok,它其實抽到紅色小圈圈的機率是2的-nx,2的-nx的entropy這麼多,ok。

123
00:33:37,480 --> 00:34:06,280
但是呢,藍色圈圈發生的機率是1,所以你去蒐集所有的這些點,它加起來的機率會是1,所以大致上這個圈圈裡面有總共這麼多個code word在裡面,所以同樣道理,y裡面也是一樣,然後呢,我們可以進一步去推導說,紅色的這個圈圈裡面的數量大概有這麼多個。

124
00:34:07,120 --> 00:34:27,820
好,那今天我的目標是什麼呢?我的目標是,我不要讓這些小圈圈重疊,這樣子的話,我最多可以塞多少個小圈圈在這個紅色的大圈圈裡面,紅色的大圈圈有這麼多個,然後呢,小圈圈有這麼多個,所以我能夠選的,在左邊能夠選的數量,不能夠超過什麼呢?

125
00:34:28,420 --> 00:34:57,580
整個右邊的紅色大圈圈的總數除上小圈圈的大小,然後把這兩個拉進來,就是h of entropy of y,減掉entropy of y given x,那根據定義,這個東西我的r就是一定要小於等於x跟y的mutual information,這樣子,ok,那當然我們可以進一步,那只是一個很loose的講法,我們可以進一步證明說,這樣子的,這樣子的那個選擇,

126
00:34:57,640 --> 00:35:27,400
就是編解碼方式,其實是會讓我的錯誤率,可以要想要有多小就有多小,ok,好,那所以其實這是,ok,這是其實是整個talk裡面最數學的部分,然後接下來我們就,呃,那個,呃,不知道照這邊大家有沒有什麼問題,ok,好,那當然我們可以去進一步去推算,

127
00:35:27,400 --> 00:35:57,380
就是,ok,剛剛是其實是剛剛剛才有這麼用一個這麼簡單的channel,呃,只有0跟1,然後有一定的機率會被翻動,其實就這樣就明明就搞那麼複雜了,所以其實這本這個學科本質上是還算蠻複雜的的一個學科這樣子,那當然我們可以去算說,ok,一般的電話線wireline就是有線的傳輸,我們通常是用所謂的additive white Gaussian noise的這個channel來表示的,同樣的架構,然後呢,類似的數學的,呃,formulation,

128
00:35:57,400 --> 00:35:57,880
然後我們可以去算出,ok,channel capacity其實是,呃,這個,是這個公式這樣子,那可能你們曾經見過log以2為底的1加上snr,其實就是這樣,它其實是這樣子來的,它只是跟你講說,我,我可以找到,我,我可以,呃,如果我要傳資料的話,我可以找到一種傳輸的方式,包含codebook,包含decoder,那我的傳輸速度不能夠超,最大最大就是c這麼多,ok,那其實這個已經,後面就比較,後面就稍微了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了解了

129
00:36:27,400 --> 00:36:57,400
稍微比較軟一點,就是我們來講一些歷史,就是那其實他,呃,這樣子的發現其實是完完全全改變的通訊系統的發展,那在二戰之前呢,就是呃,大部分還是,他還是用那種analog的對類比的通訊,我的資料其實都是用用類比的方式去傳出去的,那應該說不是資料,應該說我的聲音或者是呃,聲音等等的都是用類比的方式傳出去的,但在呃,world war two之後,所有的系統幾乎全部轉成電子的,呃,那其實,呃,這樣的發現其實是完完全全改變的通訊系統的發展,那在二戰之前啊,就是呃,大部分都還是,他還是用那種analog的對類比的通訊,我的資料其實都是用用類比的方式

130
00:36:57,400 --> 00:37:20,920
digital,換句話說,我的聲音,我的影像都會先變成零跟一之後,然後再傳出去,那比較近最近的例子就是adsl,wifi,4G,5G這樣子的通訊裡面全部都是沒有analog,沒有聲音波形的,全部都是經過,呃,變成靈異之後再傳的,然後一切都是來自於就是ok的發現,就是說,呃,

131
00:37:21,920 --> 00:37:50,840
呃,所以只要我的我的投入數據小於通道容量的話,我一定可以找到,呃,一組編碼方式能夠讓我通訊是reliable,reliable,就是說你想要錯誤率多少,多低就可以多低,好,那現在就是他現在換工程師在忙,然後宣傳給你講說我存在一組code,然後呢,我,而且我找給你看,用大數法則找給你看,可是他沒有跟你講說,哎,我,我沒有,他沒有跟你講說,

132
00:37:50,840 --> 00:38:16,840
我實際上要怎麼編碼,我實際上要怎麼解碼,對不對?我只是他只是跟你講,哎,存在我們大數法則可以找得到,但我們生活上不能依靠大數法則,工程上不能依靠大數法則,我要找一個實實在在的演算法,ok,來去做編碼跟解碼的動作,那所以這就開啟了接下來70年的找尋好的編碼方式的的的的的工作這樣子,

133
00:38:17,560 --> 00:38:36,040
那比較早的早期的工作,1990年代以前,大家都比較注重的是代數碼,像如果你沒有聽過BCHR,還有摺機碼,這些碼其實都是黑色的,這些碼其實都曾經被用到實際系統上面,

134
00:38:36,040 --> 00:39:05,080
比如說天文應用,比如說,呃,衛星,還有一些一些,比如說,還有,還有,還有這種探空,就是他探索太空的衛星上面,他們要跑到太空很遠,很遠,很遠的,非常深的太空,所以從來訊號的就是他的訊號的品質一定是非常低的,ok,那這樣子在這樣的情況下,那個他們要怎麼,所以他們需要這種這種這種。

135
00:39:05,080 --> 00:39:05,500
那種講來這種糾錯編碼方式,然後才能夠回復我要真正的訊息,包括,呃,一些各種的探測數據,以及各種的影像這樣子,ok,那呃,ok,但是其實我們可以看到說,就是橫軸是,呃,這張圖橫軸是eb除以nz,我就是其實要講的是系統的snr,這種軸是碼率,然後的每一個點呢,比如說都是我要求在10的負6次方向,呃,我要讓這種code工作在2,2分0.5這麼高的,呃,那種,呃,那種,呃,那種,呃,那種,呃,那種,呃,那種,呃,那種,呃,那種,呃,那種,呃,那種,呃,那種

136
00:39:35,080 --> 00:39:44,460
這個的速度的傳輸速度的時候需要系統需要多少的snr,早期的code其實都嗯,就是都沒那麼好,但是是早期的code

137
00:39:44,560 --> 00:40:04,900
後來最近1990年之後我們有新的code,turbocode,ldbccode,跟poltercode可能,可能都有聽過,可能在某些specs上面有看過,或者某些新聞上面看過,然後呢,呃,比較有趣的是他們一直把這些code就是推進到呃,在比如說在code rate是1 2的情況下,他把一起推進到我們所謂的權榮榜

138
00:40:04,900 --> 00:40:34,340
就是呃,就是推進到很接近極限的地方,那其實某種程度上這也宣告了一個世代的,我覺得是某種宣告的一個世代的開始跟結束,那開始的是,結束的是ok,我們我們終於找到好的碼了,他很接近,他他他非常的efficient,啊,用很少的功率,很少的很低的系統品質就可以達到這麼高的傳輸速度,ok,那接下來現在當然你開啟了另外一個新的世代,就是我們對這些碼的

139
00:40:34,600 --> 00:41:04,280
的特性其實不了解,不管是turbo code,對LDBC的code,其實都不是很了解,然後人們就呃,編碼的這個領域就慢慢的就是,尤其像工程界就轉向對這些編碼的研究,好,好,講了這麼多,呃,後面的部分,我可能就只能進行潛艇點水帶過了,就是呃,後面這個部分是講呃,所以我們剛剛第一部分講的是,ok,在宣揚framework之下,我們怎麼去處理這個,這個通道傳輸速率

140
00:41:04,280 --> 00:41:34,260
的最高上限的問題,那接下來我們進步拓展到網路,就是有些簡單的網路,像是叫做multiple access channel,他這是多個呃,傳入,假設我網路裡面有多個傳送,呃,多個多個多臺手機,我有個基地臺,那今天我要怎麼做有效率的傳輸,還有廣播網路,一個基地臺到多個手機,還有干擾干擾干擾通道,如果今天是有多個基地臺跟多個手機,那我應該怎麼做?

141
00:41:35,060 --> 00:42:00,540
那其實後面其實後面的問題的formulation其實都是類似的,我們都有encoder decoder,但然後這是他數學模型,那今天要求的是說,ok,我有傳送端,我有兩個,呃,我有兩個user,今天我要user傳message1,user傳message2,我的基地臺同時要去解message1跟message2,那我要去找一個codebook跟我的decoder去設計這些東西,

142
00:42:00,540 --> 00:42:29,880
讓我的decoder可以正確,很接近,可以正確的解出來的狀況下,我同時我要讓我的傳輸速度是R1跟R2分別不是0這樣子,ok,所以我們我要找的是R1、R2都不是0,所以我們描述這個極限的時候,我們就用所謂的capacity region,ok,那這個這個結果其實在1972年就被做出來,應該是,應該是華裔,但我猜應該是臺灣人,廖鴻俊,

143
00:42:30,380 --> 00:42:57,780
然後在夏威夷,他當時在夏威夷的夏威夷大學做出來這樣子,然後他找出來,ok,他是一個region,其實是一個這樣子一個五角形,五邊形的這樣子一個region,他只是說,超過在這個region裡面,呃,我都可以找得到編碼方式,但超過這個region之外是不可能的,那而且這問題已經被完全的解出來,不管是在這種呃,類似像這種有那個awgn,像這種有高弦的高弦noise的網路下,

144
00:42:57,880 --> 00:43:26,880
或者是任意奇奇怪怪的的channel都可以做,都是這個結果,ok,然後再來是廣播網路,同樣的formulation,我只是我要把同時要,呃,我只是同樣要把我的message給,呃,user1、user2、手機1、手機2、用戶1、用戶2的message,我要編碼之後傳出去,在message在接收端這邊,我要同時解除m1跟m2,好,那同樣的,我們要設計codebook,也要設計decoders,

145
00:43:27,280 --> 00:43:55,580
然後讓我的那個錯誤率越來越好,那這個問題在高弦的設定下,就是在我的這種有那個noise是高弦的時候,之後也被解出來,ok,那這就長出一個很複雜的樣子,但我也不想多講,然後就是這樣show給大家,就是它是一個一個這個樣子,代表說在這個曲線之下,我都可以找到編碼方式,然後讓它可以達成這樣的速度,但是這個曲線之上是不可能的,ok,

146
00:43:55,940 --> 00:44:23,420
那那後來我們人們在研究這個問題,高弦被完全解出來了,但是呃,有還有一些special case,就是一些通道的一些呃,比較奇怪的通道也被解出來,但對一般的通道而言,一般的廣播通道而言,呃,這問題還是沒有完全解出來,還是open好,再來我們就加一個更複雜的,就是雖然複雜的,這也是基本的,呃,基本的網路,就是干擾通道,我們有兩個user,我們要同時傳到兩個receiver,

147
00:44:23,740 --> 00:44:52,320
那同樣的,我們要設計codebook,我們要設計那個編碼,呃,編碼器,那in general,對於像這種網路in general的h,那個這些channel games,呃,這些hij啊,其實呃,我們這個capacity region其實是不知道的,但如果你今天我的cross things,就是我的那個叫,就是干擾的那個的power如果夠低的話,呃,是知道的,ok,這是一些,這是一個special case,

148
00:44:52,320 --> 00:45:22,200
然後我們是用所謂的,他們是用所謂的treat interference as noise,那如果是很強的,很強的干擾的話,那也是解的出,也是也是做得到的,呃,也是,那個他的極限也被找到了,那他的做法就是,我要先把我傳給他的干擾,先把這個干擾解出來之後,剩下的就是我自己的資訊,然後我再把我接受得到自己的資訊解出來,ok,那中間的部分怎麼辦呢?我們所以我們就有呃,一些呃,那個什麼就是近似的方法。

149
00:45:22,260 --> 00:45:52,160
那03年的時候,我們用就是有人提出來用degree of freedom,就是所謂的自由度,那自由度這個名詞其實有點被濫用了,統計上也有,呃,物理上面的熱力學也有吧,什麼之類的,那,那但是自由度指的是說,我可以把這個通道,呃,把它轉換成有多少個呃,平行的awgm通道這樣子,這個d就是那個平行的awgm通道的數目,ok,但是這個這樣子的簡化的方式,

150
00:45:52,160 --> 00:46:22,160
它其實是假設每一個link,就是用到的每個link的power大小都一樣,那所以我們後,所以後來就是有人畫了同樣的一群人,然後我就把就想說,那我要怎麼去把這個通道的各個不同的link power,呃,不一樣的狀況,然後怎麼把它納進來,所以我們就定義了所謂的叫做廣義的dlf,廣義的自由度,那可以廣義自由度,其實這個概念其實蠻好,我覺得蠻好理解的,就是呃,我聽到這樣理解,我聽到這個概念,我覺得蠻好理解的,就是呃,我聽到這樣的理解,我聽到這個概念,我覺得蠻好理解的,就是呃,我聽到這樣的理解,我覺得蠻好理解的,就是呃,我聽到這樣的理

151
00:46:22,160 --> 00:46:51,920
這樣的詮釋還蠻不錯的,就是你就想說,ok,我每一個link傳送端1到2,其實他們自己都有,呃,自己的,呃,自己的的那個的,呃,的的功率的的channel game的大,這個很大,這個很小,這個很小,這個很大這樣子,那呃,如果你不看其他的link,比如說傳送1,呃,第一個,這邊這個傳送到這邊這個接收,中途是看中間這個link,那我們如果是看這個的話,那它的capacity有多少?

152
00:46:52,120 --> 00:47:21,780
那這是一個awg的channel,那它的,那我們剛剛的awg的channel其實已經有解過了,其實就是大致上會等於,呃,log乘上呃,它傳的功率乘上就是呃,log1加snr啦,其實,那在snr其實就是這個值這樣子,那那在高snr的,那ok,所以那現在這個這個近似其實是在在很高的snr的時候才會有的,所以ok,我們就把alpha ij定義成這個樣子,那個alpha ij其實就是什麼呢?

153
00:47:21,780 --> 00:47:49,020
呃,我會從另外一個觀點來看,其實就是呃,呃,這個通道的什麼呢?就是它的強度,而且是in db scale這樣子,好,我們每一個通道都有都有這樣子一個alpha ij這樣子,alpha ij其實就是這個link的capacity有多少,然後呃,或者是它的通道強度有多少in terms of db,那那我們把每一個link都乘上一個,同,共同乘一個值叫做打碼,我們把可以把它取叫log p,

154
00:47:49,460 --> 00:48:17,780
那其實它就是相當於是得到這樣子的一個新的通道,叫新的網路,每一根通道的水管,就像如果把水管的話,其實每一根水管都被加出gamma倍,ok,如果今天它能夠,這個網路可以每秒傳一個bit的話,這個網路,我把它加出gamma倍之後,應該可以傳1乘上gamma個bit吧,對不對,因為我呃,就是等於是把所有的水管等同放大gamma這麼多倍,

155
00:48:17,780 --> 00:48:47,540
所以我應該可以,我的容量應該是是放大,被放大成gamma個bit,好,有了這個之後呢,我們把我們就是創造出來的新的通道,我們呃,新的通道我們寫成這樣子的模型,ok,那它跟什麼那個alpha ij有關,alpha ij就是原本通道,原本通道的那些那個的的那個各個link的強度,好,那我們在某些情況下,當我的p很大的時候,就gamma很大的時候,其實呃,這個網路是好分析的,

156
00:48:47,780 --> 00:49:17,740
那有了,那有了這個之後,我們在這個從右邊這個通道取出它分析的值,算出來多少,呃,它的網路的capacity是多少的時候,我們再把normalize,用原本的那個倍數去normalize的話,其實就可以得到左邊這個網路原本呃,我們要的那個network capacity的近似值,那我們把這近似值叫做呃,廣義的dof這樣子,ok,定義就是大概是這個,呃,成這個樣子,ok,好,終於得到我最後的部分,

157
00:49:17,780 --> 00:49:47,740
就是比較跟我們的研究相關,那呃,我們今天講啊,主要是討論就是,哎,我如果像我們這些hij啊,如果傳送端不知道這些hij的精確值的話,那該怎麼辦,那首先來講說,如果知道的話,那那會,那那會,那會發生什麼事?如果知道的話,呃,我們把這種狀況叫做perfect csit,csit是channel state information at transmitter,代表說perfect csit,

158
00:49:47,780 --> 00:50:16,940
代表說我傳送端知道我的那個hij的精確值是多少,那將其實會發生一種狀況,它的最好的傳輸的方法通常都會出現這種,都是這種所謂的比較脆弱的傳輸的方法,取比較脆弱的編碼方法,什麼叫做比較脆弱編碼方法呢?就是說,如果你今天,呃,你必須要知道這些傳輸方法高度的仰賴我的hij的精確值是多少,如果今天hij是時數的話,

159
00:50:16,980 --> 00:50:45,700
他必須要知道這個時數的值是多少,像比如說,可能如果你是近期做通訊的人,可能會聽過zero forcing,可能會聽過interference alignment,那如果你是做it的人,可能你可能聽過delete paper coding這樣子,這些東西,這些scheme其實都需要,呃,但是這個這個這個,這都是剛才比剛才更進階的編碼方式,那這些都是需要什麼?呃,我hij對hij的exactly的知識的的的了解,可是你想想看hij如果是pi的話,

160
00:50:46,060 --> 00:51:15,660
我傳送端我要怎麼知道pi的值是多少,你又不知道pi的值是多少,傳送端怎麼會知道pi的值是多少呢?所以,呃,所以我們就是你們都在想說,我要,那,那,ok,我們能不能能不能加一些,那我們就想說,那今天如果不知道的話,會不會讓一些所謂的robust schemes,就是比較,呃,呃,不會那麼,就對於衝到資訊比較沒那麼敏感的一些編碼方式,他們會不會變成是,

161
00:51:16,120 --> 00:51:35,700
是最好的呢?比較,比較,呃,像這些,比如說像什麼power control,這其實我們每天都在每天都在用的基地台,我要控制功率才不會對,呃,不會對於就是其他其他人造成影響,他傳資料給你的時候,他還不會對其他鄰近的人造成影響,還有呢,所謂的treating interference as noise。

162
00:51:35,700 --> 00:52:05,540
指的是說,呃,如果今天有干擾的話,我就把它當成是雜訊,這個也是我們每天都在用,每天基地台幹的事情,還有呢,superposition coding,那這個東西叫做,呃,如果你是做通訊的話,通訊的人的話,你聽過什麼,一個字叫做NOMA,non-orthogonal multiple access,那其實呃,跟他跟NOMA的東西是類似的這樣子,OK,那為了這樣子呢,我們就加一個,OK,我們就intentionally加一個條件,就是說,哦,

163
00:52:05,700 --> 00:52:26,340
呃,傳輸端假設我不知道,呃,通道精確值是多少,比如說,假設通道這個值hij是pi,我不知道pi是多少,但是我知道,好,它是3.1415926,啊,就是這樣子而已,代表說什麼呢?我把我的通道資訊只知道在finite precision,就是在有限精度下,那有限精度,我們怎麼去model這件事情呢?

164
00:52:26,340 --> 00:52:56,340
那其實就是把原本的這個模型,我們就加在每個channel gain上面,我們就加一個,就是一個擾動的,小小的擾動的一個factor,G1 1,G1 2,G2 1,G2 2,這些小小的擾動呢,其實就是,你可以把它想成就是,它就是一個,呃,它是一個隨機變數,uniform distributed,然後呢,它是介在0跟,它是介在1減epsilon,1減epsilon之間,所以其實它是平均為1,然後呢,會有小小的擾動,然後呢,它是介在1減epsilon,1減epsilon之間,所以其實它是平均為1,然後呢,會有小小的擾動,然後呢,它是介在1減epsilon,1減epsilon之間,所以其實它是平均為1

165
00:52:56,340 --> 00:52:57,340
那其實光加這個就可以讓我的最好的傳輸的scheme,讓它從剛才那些很fancy的這些fragile schemes壓倒變成這些robust schemes,那這些,那這樣子的就是加這樣子的CSAD效果,其實就是把這些,呃,就是光這樣,好,首先我們講,呃,由這兩個我們,由這樣子的,由這樣子的一個假設下,我們呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,�

166
00:53:26,720 --> 00:53:27,400
呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃,呃.

167
00:53:27,400 --> 00:53:34,140
這樣子的一個結果,我們就讓我們後來就是根據在這個價值家,我們做了做了做了一些研究。

168
00:53:34,140 --> 00:53:57,360
然後,然後這一系列就大概有十幾篇論文吧。當然都不是不是,全部不是全部都有做了,但我們只形容物質,比較能 worthof 兩篇這樣子, ok, 第一個是呃最開始的論文,就是我們去探討呃,像這樣子的網路這是一個 broadcast channelOK的,那E大雀色沉重斷有兩根天線,然後就算有就算有兩個人,然後沒他們個別這一根天線。

169
00:53:57,940 --> 00:54:26,900
那然後如果你是做通訊的,你可以馬上知道說,哎,那其實這個很像什麼?很像我們 zero force 你可以做的事情,為什麼呢?我這邊X1 X2,我分別我要傳資料的時候,我分別呈上一個precoding vector,然後呢,我就可以把X2對X2在X2方向上面,我就可以,我就可以讓怎麼樣X2的,呃,我就可以讓X2完全看不到這個這個這個這個這個這個訊號為什麼呢?

170
00:54:26,900 --> 00:54:55,260
因為他們這個訊號從這邊傳跟這邊傳的時候,呃,他們會產生呃相交性的干涉,讓他完全看不到,然後但是呢,同時呢,我讓user 1 是看得到的,那同時我也可以去什麼去調去調整另外找出另外兩個變數,讓user 1 看不到,user 2 看得到,所以其實我可以用這種 zero forcing 的方法,可以把這個通道變成兩個平行的通道,然後然後這樣子的話,兩個平行通道代表兩個AWGN channel,

171
00:54:55,260 --> 00:55:25,240
所以他的 degrees of freedom 就是 2,但是呢,如果今天從傳送端,但是這是有前提的,前提是說,傳送端知道精確的hij 這樣子這種資訊,需要知道精確的 channel gain 這種資訊,但如果他不知道呢,那出來的結果就是,ok,我的,我最好最好就只能做到,我的 degrees of freedom 就只能是1,我沒辦法再用 zero forcing 這樣子的的方法去,

172
00:55:25,260 --> 00:55:25,760
去抵消,去用相效性干涉的方式,去消除對 user 2 的干擾,以及對 user 1 的干擾,ok,好,那這個是他背後的一些數學細節,我就先略過,因為時間關係,然後另外一個有趣的結果是,呃,我們可以用剛才的那個,呃,剛才的那個,呃,一些衍生出來的數學,就是其實就是這個這個這個這個這個工具數學工具吧,呃,然後進一步去看看大型的數學,呃,然後進一步去看看大型的數學,呃,然後進一步去看看大型的數學,呃,然後進一步去看看大型的數學,呃,然後進一步去看看大型的數學,呃,然後進一步去看看大型的數學,呃,然後進一步去看看大型的

173
00:55:55,260 --> 00:56:25,220
網路,我們有什麼,有什麼樣的特性,那我們考慮,首先我們考慮就是這種,呃,除了大型,其實都是 arbitrary large,就是我們 general,我們有 k user 在裡面,k 個,k 個記憶台,k 個,呃,k 個用戶這樣子,ok,傳送端接收端,然後呢,他們之間的網路可能有自己的各個的功率,那個什麼,那個強度的大小,好,然後我們,那如果我們允許我們這些傳送端的各個記憶台,讓他們怎樣,讓他們

174
00:56:25,220 --> 00:56:54,120
去 cooperate,讓他們去,呃,讓他們去合作,使得說什麼叫合作呢?我的,使得說我傳給這些 k 個 user 的的的的訊息,之前沒有合作的時候,是我每一個 x 1 到 x k,其實都是獨立編碼,有合作的狀況下是我可以共同編碼,所以共同編碼其實是有好處的,那共同編碼,你知道,把這種狀況的做 transmitter cooperation,ok,共同編碼是有好處的,那我們好處的好處到底有多少?

175
00:56:54,120 --> 00:57:24,080
那馬上馬上我們馬上的想法就是說,哎,也許如果可以的話,我們去把,哎,這個這樣這個網路在沒有沒有合作的情況下,他的可拍攝的 region 找出來,有合作的狀況下,可拍攝的 region 找出來,他兩個一處,我就知道了嘛,對不對?就是就知道他的比值有多少,就算我們這個其實就有兩個問題,馬上就有兩個問題,第一個問題是,我們根本不知道,呃,現在的理論根本不知道這兩個的 capacity region 是是多大?

176
00:57:24,340 --> 00:57:48,780
長什麼樣子?就算知道,他一定是什麼呢?這些 alpha ij 的函數,這邊裡面有 k 平方個 alpha ij,所以最後我一定會遇到一個問題,就是,呃,我裡面太多的參數,我根本沒辦法分析,就算你知道他長什麼樣子,那個樣子已經非常非常複雜,然後你看大家,然後如果你 present 給別人看,別人可能跟你說,手滑,那又怎麼樣?

177
00:57:48,780 --> 00:58:18,760
但是我們還是想知道這個答案啊,就是我們還是想知道說,到底可以帶給我們多少好處?所以我們就用一個方法,就是叫做 extreme network theory,他只是說,OK,我就,呃,我們問一個這樣子比較籠統,我們用一個更,因為問一個更精確的問題,就是說,好,在有合作的情況下,我的,我的那個,呃,some capacity,就是我的所有的 capacity 的核最大能夠多少?

178
00:58:19,780 --> 00:58:48,760
那個 capacity 是多少這樣子,除上什麼呢?如果我今天,呃,我們除上什麼呢?除上,等於說除上這個值,這個值就是拿來當基準用,這個值指的是說,當我沒有 cooperation 的時候,那我一般用的方法就是用,呃,一般現在目前大家都在用,就是一般我們日常生活中,基地台都在用的,OK,那我們來看看,那我們去以這個當基準狀況下,不同的 alpha 有不同的分子跟分母,

179
00:58:48,760 --> 00:59:16,860
那我們想要知道這個比值最大最大是多少,OK,那這個就是,呃,所謂的 extreme gain,OK,那我們有這個結果,這個字比較,這是,這就是我的博士論文的一部分,講這麼久才會講到,講到博士論文,OK,他只是說,他只是說,OK,我們就是去把這個 gain 算出來,如果今天,呃,那這個 gain 其實是跟我的所謂的 channel regimes 有關,channel regimes 只是說,我的 alpha ij,他,我們不能夠讓 alpha ij 就是任意值,

180
00:59:16,860 --> 00:59:44,960
我們可能把他縮小到某一個有意義的一個區間,有意義的一個,一個小,一個子集裡面,然後呢,我們找一個小的子集,然後我們發現說,呃,其實 cooperation 其實沒有太大的幫助,就 cooperation,不管 k 是多少,只給我們 1.5 倍的,的速率的,的 gain 而已,但如果今天我們把它放寬一點點,換到另外一個稍微大一點的子集,OK,那我們會發現說,這個 gain 會快速的增加,

181
00:59:45,260 --> 01:00:14,940
那這是比較 surprising 的點,因為我們會原先預期是說,OK,那個 treating interference as noise,這個已經夠好了,就是,就是我們目前都正常在用的那個狀況,但如果今天如果你放寬,我們讓這個,這個網路的這些,呃,這些 power 啊,這些 alpha ij 可以能夠取更多一點的值的話,那我們就會發現,哦,他不是只有 constant,他的數,他的那個 gain 其實是會隨 log 增加的,

182
01:00:14,940 --> 01:00:44,940
但是是用 log,會隨 log k 增加這樣子,OK,好,所以就是這是我今天的 talk,所以,呃,就是我剛剛 delay 大概七分鐘吧,對,所以,呃,主要是三個部分,第一個,我們是嘗試著去把,用三十分鐘內把那個 Shannon 的 theory 把它講完,然後以及給他大家解釋說,OK,他的架構是什麼,他的,然後什麼是 channel capacity,他怎麼做到這件事情,然後我們簡單回顧一下,就是,呃,就是現在基本有些東西,就是,呃,就是現在基本有些東西,呃,就是現在基本有些東西,呃,就是現在基本有些東西,呃,就是現在基本有些東西,呃,就是現在基本有些東西,呃,就是現在基本有些東西,呃,就是現在基本有些東西,呃,就是現在基本有些東西,呃,就是現在

183
01:00:44,940 --> 01:01:14,900
這些基本網路以及他目前的那個解的現狀,然後最後呢,我們把就是實際的狀況考量進來,呃,當我的通道資訊並不是只是現在有限的精度的時候,我們會有,呃,一些奇奇怪怪的現象發生,也不是奇怪,就是有一些有一些那個意想不到的現象發生,第一個就是像是我們的多天線常用的 zero forcing 不再適用了,第二個是那個我們可以用來用這樣的工具來進一步的去刻劃大型的網路,

184
01:01:15,100 --> 01:01:23,100
呃,他們相對於一般的,呃,呃,相對於一般的簡單的 scheme 下面,他那個最好可以做到什麼樣的程度?

185
01:01:24,060 --> 01:01:26,940
好,以上就是我今天的 talk。

186
01:01:26,940 --> 01:01:29,940
整理&字幕由 Amara.org 社群提供

187
01:01:56,940 --> 01:02:22,940
整理&字幕由 Amara.org 社群提供

188
01:02:27,940 --> 01:02:33,940
我覺得這好像蠻有趣的,呃,那觀眾這邊有沒有什麼問題呢?

189
01:02:34,940 --> 01:03:00,940
我對最後這一段的這兩個結論都還就是想要知道更多那個意思,就是 zero forcing 你就說他在 CSIT 就是不不不準的狀況之下,就會有一個這個好像意想不到的這個效果,但其實 zero forcing 應該現在就有在備用吧,就是我要如何去解讀這個結果?

190
01:03:01,940 --> 01:03:28,940
OK,他意思是說 zero forcing 現在有在用,但是,呃,應該是說就是如果你要,當然我們這些結果都是希望讓你可以得到,呃,編碼,就是就是 reliable communications,就是我要讓我,如果我的要求是錯誤率可以,呃,需要需要任意小的話,那我的,呃,我我我最好可以做到什麼樣子?

191
01:03:29,940 --> 01:03:42,940
那今天再跟你講說,如果今天在我的通道資訊的精密程度精確程度有限的話,zero forcing 可能沒有辦法達到,呃,可能沒有沒有辦法達到你預期想的效果。

192
01:03:43,940 --> 01:04:05,940
OK,假設通道資訊是,呃,呃,精確的,那你透過 zero forcing,你可以達到像我剛剛講的 reliable communications,我的錯誤率可以到要有獨立就有多低,但如果今天通道資訊不全的話,我可能就沒辦法做到這件事情,呃,不是可能沒有,是呃,沒有,應該是在高 SNR 的情況下是絕對沒有辦法的。

193
01:04:06,940 --> 01:04:20,940
可能是我覺得這個 degree of freedom 的了解不是那麼,那麼你知道,我不是這麼了解,就是他比較像是一個一個 data stream,兩個 data stream 的這個感覺嗎?

194
01:04:20,940 --> 01:04:46,940
對對對,degree of freedom,如果你不看 generalize 的情況下,一般呃,比較古早的 degree of freedom,有點像是 data stream 的感覺,但是呃,後來我們畢竟他我們後來最有興趣還是 channel capacity,還是整或是整個 network capacity,或是整個 capacity region,那要不是 network capacity,我們解不出來啊,那我們需要找一個 approximation,需要找一個能夠近似他的東西。

195
01:04:46,940 --> 01:05:15,940
那所以我們就有,就把那個原本的 degree of freedom,把他這個這個這個概念把它推廣,他除了能夠說明說我有多少 independent stream 之外,我還可以用拿他來近似我的 capacity region,為什麼他可以做這樣的近似的原因是原本的 DOF,假設我每一個 link 都是一樣的大,功率都一樣強,他們的 link end 都是一樣的。

196
01:05:16,540 --> 01:05:44,300
Channel end 都是一樣的,但是 generalize degree of freedom 可以允許我的不同的 link end,我的不同 link 有不同的 power,譬如說像這些我可以 assume 說,ok,這個 direct link 都是很強的,有 10 db,然後呢,crossing 可能很弱,可能是 0 db 這樣子,然後用用這樣的假設下去看我的 network,就是我的 capacity region,大致上長什麼樣子。

197
01:05:44,980 --> 01:06:07,840
那這個結果的話,當然我們就進一步退過來,我們進一步就把這個問題簡化嘛,然後就要 degree of freedom,他是跟你講說,所以我們還是可以用那種就是有多少個 independent stream 來表示,那在 perfect css id 的時候,他跟你講說,ok,我真的可以造出兩個 independent stream,

198
01:06:07,840 --> 01:06:27,840
然後呢,在每個 independent stream 上面,我們都可以實現 reliable communication,都可以讓我的錯率要多低就多低,但如果今天通道精度不夠的話,他就跟你講說,這件事情我們 reliable communication 做不到。

199
01:06:37,840 --> 01:07:01,360
另外一個東西也很有興趣,是後面的那個結果你有兩個不同的 set,然後你說在就是第一個 set 的時候是 1.5,然後第二個 set 是 k,這兩個 set 能不能再就是稍微講解一下,就他們的特性是什麼,他就是如果他是像 linear algebra,如果你有一個 matrix,然後他會有就是這個什麼 eigenvalue 或什麼什麼之類的東西嗎?

200
01:07:01,360 --> 01:07:31,120
好,這個 set 其實他就是所有可能的 αij,αij 其實就是各個通道的強度 in terms of dB,所以譬如說 αi,這根可能是 10,就代表它是 dB,所以他可能可以取任意的值,那我這邊的這個 subset,這個 TIN subset,它是說可能的 αij 的一個子集合,那子集合滿足什麼樣的特性呢?

201
01:07:31,360 --> 01:07:59,480
呃,這幾個直接跟你講說,當我的 transmitter 不允許合作的時候,就是把這個方框拿掉的時候,這些 αij 在這個集合裡面的話,treating interference as noise 跟 power control 最好的,你沒有辦法做得比他更好,in terms of gdof。

202
01:08:01,380 --> 01:08:18,320
那 ok,這個是這個子集合的定義,所以我們就在想說,那我們在這個子集合裡面,當我不允許合作的時候,treating interference as noise 是最好的,那如果允許他合作呢,那他會不會帶給我們很好的 gain?

203
01:08:18,320 --> 01:08:30,760
如果這個 gain 很大的話,代表說什麼呢?代表說我在工程上面我花很多精力去研究怎麼樣讓這些 transmitters 可以合作,是有幫助的嗎?

204
01:08:31,440 --> 01:08:54,440
那結果顯示,這 gain 很小,而且他跟 k 沒有關係,他的 gain 最多就是 1.5 而已,ok,那這是剛才的那個講法,那這個集合裡面有個特性,就是我們每一根我的 crossing 其實都,他的那個 dB 數其實都,就是這些干擾的 link 其實他們的功率都很低,有多低呢?

205
01:08:54,440 --> 01:09:23,820
In terms of dB 來看的話,我的每根 direct link 要大於任何一根發出去的 link,加上任何一根收進來的 link,然後這是他的定義啦,對,但是如果你進一步擴大,就是 SLS 是,這是我們另外一篇論文,另外一篇是講說,ok,在某些,如果今天只有三個 user 的話,ok,那我們可以找到一個 coding scheme,

206
01:09:24,540 --> 01:09:51,380
然後證明他是 optimal, in terms of gdof,但,ok,那我們就想說,我們進一步把這個定義推廣,然後我們定義一個 region 叫做 SLS region,然後我們去看他,那這樣子的話,我的 transmitter cooperation 的 gain 有多少,那我們發現說,他的 gain 其實是會隨著 k 增加而增加的,而且是以這個速度在增加的,那個 k 在增加的,那代表說什麼呢?

207
01:09:51,380 --> 01:10:02,540
代表說,ok,雖然我放寬了一點,其實我只是從 team 到 SLS 到只是放寬了一點點,但他給我的 gain 其實是很高的,那代表說什麼呢?

208
01:10:02,860 --> 01:10:31,780
其實有兩個 implications,第一個是,there must be something inside,就是說我們,雖然,應該說就是,我們去找這個 ratio 的時候,其實找的是所有網路在這個集合裡面的最大值,代表說有些特別的網路,特殊網路,會讓這個 gain 其實是很高的,ok,

209
01:10:31,780 --> 01:10:50,460
所以在這種特別的網路,可能我們就進一步研究,他到底發生了什麼事,或是他的周邊,他的 neighborhood 到底發生了什麼事,為什麼可以讓他 gain 這麼高,讓 cooperation 可以到這麼好,那另外一個,當然這是一個正面的結論,

210
01:10:50,460 --> 01:11:07,660
那另外一個比較負面的結論是,也許這個可能真的是特例,某些在這個裡面,並不是所有的網路都可以讓他這麼高,可能是只有一些特別的案例,才會讓他這麼高,但是 in general 而言,是不是真的還是這麼高呢?這也是接下去我們要問的問題。

211
01:11:08,620 --> 01:11:25,580
所以從 TIN 到 SLS 放開的東西到底是什麼?就是一樣也是,就是在就是 cross link 的 order of magnitude 的差異上,對對對對對,呃,SLS 的話是,呃。

212
01:11:25,580 --> 01:11:55,540
他其實是把 team 的一些條件放寬,因為 team 的條件是要求我的我的我的 directing 的功率要大於任何發出去的 link,加上任何收進來的 link,那 SLS 的話是他有在做進一步對這個條件做放寬,因為你想想看哦,如果今天沒有放寬很多對不對?呃,沒有放寬,沒有放寬很多,呃,應該說對沒有放寬很多,我們有做一些。

213
01:11:55,580 --> 01:12:18,620
就是呃,我們在論文裡面其實有講,有提到一些基本的,呃,應該說用一些用一些特例說明說哦,這個上面這個是下面這個子集子集合,但是他並沒有放寬很多,那你們有沒有在下一個結果是,就是例如說加持所有的 link 的 magnitude 都差不多的話,大概會是什麼樣的結果?

214
01:12:19,340 --> 01:12:47,540
我們目前沒有這樣的結果,呃,就是你講,你先問問的很好,就是呃,其實我們老闆也是也是接下來再問,就是說,那我們下去去做,那目前的得到的結果都是我們沒有足夠的數學工具去去去算這些東西,接下來的就沒有足夠的數學工具,我們需要更多的,呃,應該說我們數學工具其實其實就是這個了,其實就是這個,那他也有不同種的形式。

215
01:12:48,020 --> 01:13:01,100
那我們也在發現,一直在發現有很多種不同的形式這樣子,那只是到目前為止,我們並還沒有,還沒有發現到足夠的工具可以去處理,你剛剛講的這個的延伸問題。

216
01:13:01,100 --> 01:13:21,820
主持人杰分析,呃,我可以問一下那個 team 的概念嗎?就是你剛剛我說的概念是指說,其實 direct path 的 gain 會,呃,可以把它想成其他過來的 interference 相對小嗎?

217
01:13:22,300 --> 01:13:51,500
所以在這種情形下,是不是說,其實我有沒有 transmitter 的 cooperative,基本上,呃,對於旅行來說,他都是一個很好自己解自己的真正要的呃的訊號的的這種場景,所以你的這個 game 就不會太大,不管你有沒有傳送端的 cooperative,那另外一個什麼 SLS 這個是指說,放寬了說,呃,我可能 direct path 跟我的 interference 這個強度可能已經接近一比一了,那這個時候可能,呃,這個時候就要靠

218
01:13:51,500 --> 01:14:16,100
user 數的變多來增加我這個,你這邊的 extreme of game 這樣子嗎?呃,要是增加的,你用者數變多,他可以增加,呃,整個網路的,就是整個網路的,就是傳輸的效率這樣子,就相對於相對於聽來講的話,去相對訓練,原本訓練就不是那麼的有效率的。

219
01:14:17,100 --> 01:14:40,220
OK,那我可不可以有,呃,如果以工程師的 common sense 來抓的話,如果呃,其實我想知道說,那照這樣的說法,說 K 越大代表我的,呃,這個這個有沒有 transmitted 的 cooperative 群會帶來的正義會隨著 K 的變大而增加嗎?那這種前提是說,我這通道的 CSIT 還是 perfect 嗎?

220
01:14:40,220 --> 01:14:40,740
不是,我這邊假設通道 CSIT 都是 finite precision,就我剛剛講的就是,呃,假設通道是 pi,那我只知道 3.14159,嗯哼,對,我的假設,那這邊的假設就是這樣子,嗯哼哼,那那那我的,呃,可不可以理解一下,那意思是說,在 finite precision 的這個前提之下,呃, K 越大,其實這個,因為你 finite precision 嘛,代表你還是有不準的地方,那到底是他對,呃, K 小一點點,然後 K 等於 3,他帶來的這個,呃, K 越大,其實這個,因為你 finite precision 嘛,代表你還是有不準的地方,那到底是他對,呃, K 小一點點,然後 K 等於 3,他帶來的這個,呃, K 越大,其實這個,呃, K

221
01:15:10,220 --> 01:15:38,220
的影響,跟 K 等於 100,他帶來的影響,哪一個會比較嚴重呢?假設我一樣,準度都是 90% 的 channel state information 的話,嗯,嗯,大概來說,會哪一個比較嚴重?比方說 K 等於 3,我可能是,呃,這個,這個,這個 GAN 可能有,可能 GAN 是,是 10%,但是我如果 K 等於 100 的話,欸,搞不好這個 GAN 可能就會變成,呃,可能會傷害只有 7%,但是像這樣的,有沒有辦法大概抓一個 sense?

222
01:15:38,220 --> 01:15:45,500
說傷害嗎?就是,呃,他不準度對那個,不準度對 K 的變大影響是越嚴重呢?還是越不嚴重?

223
01:15:46,060 --> 01:16:08,140
OK,這就回到我們剛才的假設,就是通道資訊的假設,其實我們剛剛假設,就說這不準度是 Epsilon 嘛,對不對?如果我知道,假設這個,這個,這條是 Pi 的話,那我只知道 3.1415926,那這個 Epsilon 其實是決定,就是我知道到底多少,如果今天這 Epsilon 越大,代表我知道的精確的程度就越少,對不對?

224
01:16:08,700 --> 01:16:29,260
那,我們這理論是跟你講說,不管 Epsilon 只是多少,只要他不是 0,都會有剛剛那個結果,所以你剛剛講的那個,就是比如說,噢,不準度 10% 跟不準度 1%,就相當於是,假設通道資訊是 Pi,我只知道,傳送端,我只知道 3.14,或者是 3.1 的差別,對不對?

225
01:16:29,780 --> 01:16:41,140
那,在這種情況下,在我們的模型的設定下,在這個,或是在這個,因為在這個分析架構下,呃,這兩個的對於結論都是一樣的。

226
01:16:41,860 --> 01:16:56,980
OK,所以你 Sorry 來說, K 越大,可以帶來更多的,你剛剛的 external gain,然後沒有任何的 side effects,是在,呃,假設我一樣,呃,不準量一樣, Epsilon 一樣的話,其實 K 越大,也不會有額外的傷害,是這樣理解嗎?

227
01:16:57,380 --> 01:17:12,740
對,對,對,對,對,因為其實這個你要理解這些,所以我們要去理解這件事情,其實是有個前提,就是因為我們都是在 GDL,就是 Generalized Degrees of Freedom 的這樣子的架構下,那 GDL 的架構下,其實是會讓我的所有的那個 scaling factor,就是剛剛的 log P 全部拉到無窮達去。

228
01:17:13,740 --> 01:17:27,140
OK,所以其實不管是 1% 的不確定性,還是 4% 的不確定性,3,直到 3.14 跟直到 3.1,呃,當在 P,到到無窮達,log P 拉,scaling factor 拉到無窮達的時候,其實都沒有差。

229
01:17:27,720 --> 01:17:40,560
OK,所以 in theory 來說,其實 K 越大就一定更好,只是我們這邊可能沒有想到一些,呃,要 cooperating 的他的 complexity 要怎麼處理這些,先不考慮之下,K 越大理論上 theory 來說,他帶來的爭議都是好的。

230
01:17:41,240 --> 01:17:50,380
對,OK,應該說 K 越大的話,大家需要合作,如果不合作的話,就會收,就會撕很多吧?

231
01:17:51,260 --> 01:18:05,340
嗯,應該說,應該說,如果你合作,其實你說合不合作,其實我會這樣,我會比較這樣看啊,如果你合作,是有機會可以帶來更好的那個效能爭議,因爲什麼叫做有機會呢?

232
01:18:05,600 --> 01:18:17,560
因爲我這邊算的是什麽,extremal gain,就是說我去找遍網絡所有的,網絡裏面所有的 α ij,只要在這個集合之下,我會找這個比值的最大值。

233
01:18:17,860 --> 01:18:30,240
所以當然有可能我的某一種網絡,就是我的某一種 α ij,同樣也是在這個集合,但它的 gain 很少,可能只有 1 點多,或是 1.01 這樣子。

234
01:18:30,560 --> 01:18:56,060
但我今天要問的不是說平均,我不是要問最低,我是要問最大可以到多少,所以我的詮釋是說,應該說是有機會,如果今天 K 越大,是有機會能夠讓我透過合作,我們可以同時取得更多的 capacity gain,更多的傳輸的效能。

235
01:18:56,780 --> 01:19:02,060
所以這時候,傳送端的合作效益就會產生出來。

236
01:19:03,060 --> 01:19:27,500
主持人:「就是 follow up,就是這個 concept,這就已經不是你論文的範圍了,但是就也蠻有興趣知道說,假使我今天是討論精準的 CSIT versus 沒有精準的 CSIT 的這個比如說比例,然後它對 K 有沒有 dependency?」

237
01:19:28,000 --> 01:19:32,280
賴慈泓議員:「OK,比例是指說…」

238
01:19:32,280 --> 01:19:34,780
主持人:「就是一樣把它相處,就是有沒有…」

239
01:19:34,780 --> 01:19:56,380
賴慈泓議員:「OK,有。其實如果是 perfect CSIT 的話,這個問題就很好解,因為我有 K 一個傳送天線,然後它們可以互相合作,基本上就是一個 missile forecast channel,然後我有 K 一個 user,每個 user 都是只有單一天線的,所以我可以做 zero forcing,如果是 perfect CSIT 的話,我可以 zero forcing。

240
01:19:56,900 --> 01:20:18,040
讓等同於什麼?如果做 zero forcing 的話,其實你可以比如說讓第一個 precoding factor 的效果會把 2 到 K 的所有 user 傳到那邊的訊號全部取消,然後第二個 precoding factor 是只留 2,不留其他的,第三個 precoding factor 是只留 3,不留其他的。

241
01:20:18,120 --> 01:20:29,060
所以在 perfect CSIT 的狀況下,這個 cooperation 我可以達到 some degree of freedom,其實就是 K。

242
01:20:29,060 --> 01:20:49,020
主持人:「其實這個值就是 K 這樣,假設我們是 DOF 嗎?但是對於 treating interference as noise 呢?這時候假設我們每一個 link 都是一樣的強度的話,treating interference as noise 只有 1 吧?」

243
01:20:49,020 --> 01:21:12,000
主持人:「對,只有 1,因為我們傳了 1 個之後,假設我們每一個 link 的強度都是一樣的話,我第一個天線傳什麼東西,我的 1 到 K 的 user 全部都會收到類似的東西,同樣 power 的東西,所以其他人其實就沒辦法再傳了。

244
01:21:12,440 --> 01:21:24,720
分母的部分就是 1,我們應該是可以證明出這個比值最大最大就是 K 除以 1 這樣子。

245
01:21:24,720 --> 01:21:43,260
我們剛剛那個是converse,achievability 就是我剛剛講的,我們剛剛用 1 組 α ij,α ij 全部都是 1 的狀況下,我們可以用 zero forcing,讓分子是 K,分母是 1,所以我直覺這個值應該就是 K。

246
01:21:44,260 --> 01:22:01,100
對,所以這也是跟我們講說,如果是當我們是 final decision CSIT 的時候,這個問題就不是那麼 trivial,這個後來證明其實寫得有一點,所以後來大概想了大概半年,才把那個 converse 證出來這樣子。」

247
01:22:01,100 --> 01:22:17,840
Q 問:「那如果不是切是不是 cooperation,就是假設我們都假設他已經是 cooperation 了,但是去比 precise 和不是 precise 呢?」

248
01:22:18,080 --> 01:22:34,620
Answer 問:「嗯,你是說假設沒有 cooperation,然後去比 precise,OK,有,這個有解,你應該講的是像這種 interference channel,如果是 perfect CSIT 的話,

249
01:22:34,620 --> 01:22:57,260
他的,如果是 perfect CSIT,然後我們討論是 DOF,degrees of freedom,那我們可以用 interference alignment,然後可以知道 some DOF 是 K 除以 2 的這樣的結果。

250
01:22:57,440 --> 01:23:11,700
但如果今天是 final decision 的話,這個結果會跟你講他最後只有到 1,那這個是這篇 paper 的另外一個小結論。

251
01:23:11,700 --> 01:23:27,060
所以有 cooperation 跟沒有 cooperation,如果說是在 interference channel,是 perfect CSIT 跟 final decision CSIT 的比值,他的比值至少是 K 除以 2。

252
01:23:27,700 --> 01:23:44,920
好,那最大值 K 到多少?這個就沒有再深究下去了,因為 K 除以 2 就是 order of K 啦,應該就是一個上進的東西。」

253
01:23:44,920 --> 01:24:03,560
Answer 問:「那我們理解應該是說,當 network 越大的時候,然後你這些不精準的 channel,就是總體造成和你如果全部都是精確,本來就是會有一個這個差異,然後這個差異會隨著 K 成長。」

254
01:24:03,760 --> 01:24:05,760
Answer 問:「限性增大。」

255
01:24:05,760 --> 01:24:35,300
Answer 問:「對,我要補充一點,為什麼我們會有這個假設,為什麼我會把它假設成這個樣子,為什麼我把它叫做 finite precision CSIT,我剛剛講如果假設通道是 pi,那我們只能知道 3.14159,假設通道是時速的狀況,那如果今天譬如說它是有理數呢,就是一個 finite precision 的值。」

256
01:24:36,760 --> 01:25:04,000
Answer 問:「不管它是時速還是 finite precision 的值,但是如果它的位數是很後面很大的話,我一般的電路、電腦應該也是沒有辦法處理到這麼,應該說一般的 IC 是沒有辦法處理到很精準的值的,就是 IC 會有,你在做 IC 的時候,你在處理負點數的時候,處理小數的時候,它都會叫你選,你要用 floating point 還是要用 fixed point,那一般的 fixed point,聽眾裡面應該是有做硬體的人,

257
01:25:04,000 --> 01:25:22,800
然後當你知道說有 fixed point,那我們就要設定進度是多少,那這時候在 IC 設計上面設定進度多少的時候,其實就會引入這樣子的 finite precision 的效果,那這也是我們會做這樣的假設的另外一個用意。」

258
01:25:23,460 --> 01:25:34,900
主持人:「其實這個東西對 wireless 來說也很有意義,因為在做 channel feedback 的時候,你不可能,你就只能有幾個 bit,然後那個就會是你的 precision。」

259
01:25:35,220 --> 01:25:52,400
主持人:「對,我記得就是現在的 5G 是有一個 mode 是可以回傳,就是你量到多少,然後就會傳那個值是多少,但是是有那個 precision 的那個的問題啦。」

260
01:25:52,920 --> 01:25:59,400
主持人:「但我覺得都沒有那麼有意義啊,就是你本來在量的時候就一個誤差,你在傳的時候又一個誤差。」

261
01:25:59,400 --> 01:26:05,820
主持人:「對,誤差有誤差加誤差,就是大誤差,然後就會變成似不像這樣子。」

262
01:26:06,300 --> 01:26:09,740
主持人:「你是說一個沒有必要比另外一個更大?」

263
01:26:09,740 --> 01:26:12,740
主持人:「嗯,我懂你意思。」

264
01:26:12,740 --> 01:26:42,740
主持人:「我可以問一個在場應該都會覺得我很蠢的問題,就是這裡的 α11,α12 是什麼東西啊?就是你說是 GAN,但是為什麼它可以是虛數,然後就是我的理解是這裡都已經是 binary 了不是嗎?就是全部都是 0101,那為什麼還有什麼 GAN 還有...。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。。�

265
01:26:42,740 --> 01:27:12,720
OK,好的,它是這樣,就是 α 的定義其實是這樣,就是如果我今天原本的,像我們這邊剛才講這些都有,像這些我訊號傳過來的時候都會經過通道,然後通道就會呈上一個 h 嘛,對不對,hij 這樣子,這個 hij 其實就是那個什麼,所謂的 channel gain,就是 wireless channel gain,就是我在過去的時候,可能通道傳過去的時候,我呈上一個這樣的 factor,用來表示,OK,這邊有建設性干涉,我享受性干涉。」

266
01:27:13,220 --> 01:27:36,220
然後這個 hij in general 是一個負數,那為什麼它是負數字?哦,這是一個非常非常 long story,這個大家要講四、五個禮拜,基本的 communication 101,對不對,是要辦法講清楚的,對,你就讓它是一個負數,然後,但是呢,我們這邊的話是,啊,不好意思,剛才是不是我打斷誰?

267
01:27:36,220 --> 01:28:05,220
我只是想,如果簡單要解釋這個負數,是不是可以簡單用證交,就是 sine 跟 cosine 本身是證交,你本來就可以在兩個不同的 phase 上去送訊號嘛,所以其實你只是通道 model,把它 model 成,在 in phase,sine 這邊可能送一個 α,而送一個 a,然後在另外一個證交的 domain 上是,cosine domain 上可能送一個 b,所以其實任何這種通訊 model 可以 model 成一個負數,那所以你的 channel gain 當然也可以是負數這樣子,對,簡單理解。

268
01:28:06,220 --> 01:28:36,180
是,我覺得這是對,就是我,我在,就我,我是物理的,所以我,我都是做 analog 的,所以,但是我的理解是,這些 x 1,就是這些,這些 code 不是都已經是 bit 了嗎?這是 0 1,0 1,0 1,然後為什麼還有個 gain,就是你要乘什麼東西,好,這個我可以解釋,就是我們現在是,我們剛剛剛才是 0 1,0 1,0 1 嘛,對不對,是建立在那個所謂的,呃,我等下。

269
01:28:36,220 --> 01:29:05,280
看看能不能回去,是建立在,呃啊,哦,就是這個模型,就是個 bsc,這個模型下面,這個模型只吃 0 或是 1,然後突出也是 0 或者是 1,但是是一個極端簡化的模型,然後它就只是捕捉說,ok,如果你今天傳,傳了 0 1,0 1 進來,然後呢,會有一些,有一定的機率被翻動,然後你突出是,有,有,有變,有被翻動過的東西,然後你要怎麼去,問題是你要怎麼把它解回來,

270
01:29:05,280 --> 01:29:05,400
但如果今天我們進一步擴展,比如說到,呃,所謂的 AWN channel,這個 channel 的話,是我的輸入,呃,就是我的所有 noise 其實是什麼,其實它是一個高時分佈的 noise,它可以取值,呃,正,呃,負現在這種,就是用個中心曲線的高時分佈,不是常態分佈,然後呢,我的 x 1 到 x 2 的取值可以是時數,或者是負數,就 depend on 你,你要,你要的那個,我這邊,你,我這邊,你要討論 scope,就是,呃,我這邊就是假設都用,呃,我這邊就是假設都用,呃,我這邊就是假設都用,呃,我這邊就是假設都用,呃,我這邊就是假設都用,呃,我這邊就是假設都用,呃,我這邊

271
01:29:35,280 --> 01:30:05,260
是用時數好了,那它的限制,我不可能,當我的 x 不可能達到無限大,比如說我能不能傳一千萬進去,然後 noise 可能很小,那我就就等於是 noise free 嘛,對不對,就會無敵了,但是那你這樣不行,我們就會有,所以我們就會有所謂的一個 power 的限制,這樣子,所以在這個後面的後面,後面的所有的 wireless network 的模型,就是根據這個 AWN channel 的模型,比如說,就是說,延伸的所有的 x,y,z 都可以是時數,都可以是時數,對,

272
01:30:05,280 --> 01:30:35,260
然後 y 甚至可以是複數,呃,x,y,z 都可以是複數,就是在進更進一步,我們把那個那個,因為其實你可以想就是想把想像成 x,y,z 其實就是兩個兩個互相獨立的通道,就是有時軸跟跟虛軸,時軸一個通道,虛軸一個通道這樣子,對,然後如果是複數的話,這個就沒有二分之一了,它的 capacity 還就變成 log 1 加上 snr,

273
01:30:35,880 --> 01:31:05,060
就是您可能會有聽過這個什麼 log 1 加 snr 是系統的 capacity 之類的,你可能會,對對對,他 ok,他 ok,所以所以其實我的 x,y,z 其實都可以是複數,那我們再回到剛才的這邊來,就是這些這些東西,我們這些東西都可以是複數,然後,然後為了就是為了討論討論期間啊,就是我們在我們在論文裡面,其實我們都假設都是時數啦,

274
01:31:05,060 --> 01:31:35,020
就是因為複數其實就是就是什麼又乘兩倍這樣子,然後所以我們假設是時數,所以時數的話有可能有正有負嘛,所以我們就會加上一個那個加一個絕對值,然後去平方,這個東西就是他的 power gain,就是我訊號通過這個通道的時候,比如說那個transmitter 1 到 receiver 1 這個通道的時候,他收到的 power gain 有多少,他 power gain 可能是 10,可能是 0.1,對,然後呢, pj 是那個,pi 是就是,呃,p1 就是他

275
01:31:35,060 --> 01:32:05,020
這邊有的發射的功率,然後所以 log 乘上發射功率乘上什麼呢,log 發射功率乘上 channel gain,其實就是接收到的,收到的訊號的功率大小,ok,對,然後呢,但是在還就是在高 smr 的時候,我們剛剛看到在那個什麼,剛剛的那個 channel capacity 的的的公司是 log 1 加 smr,對不對,嗯,那 s,那是很高,比如說 sr 等於 100 萬的時候,

276
01:32:05,460 --> 01:32:35,020
e,那個 e 就,e 就有跟沒有一樣,所以跟 e 可以省掉,所以就變成是 log smr,所以就變成是近似成這個樣子,對,所以,所以代表說什麼呢,我的每一個 alpha ij 對應到的是,呃,各個 link 的功率大小有多少,這是他的,從他的基本定義來的,然後為什麼我們要這樣定義呢,是因為這樣子的定義是跟我的,

277
01:32:35,020 --> 01:33:04,620
每個 link 的 capacity 是有關係,我只要把每一根 capacity 都乘上 gamma 倍,把每根水管都加粗,然後呢,我知道我,如果我知道能夠分析,如果我能夠有些工具分析右邊這個,這個比較加粗水管的的的的 network 的話,所謂的分析就是說,我知道他的,比如說我可以知道他的 channel capacity 是多少,我知道他的那個最大的傳輸的速率是多少,知道他的 capacity region 是多少,嗯,

278
01:33:05,020 --> 01:33:34,980
我在把那個東西或是那個值除上 gamma 倍拉回來,我就可以知道左邊這個通道的大致的capacity 是的的估計值是多少的一個近似值是多少,那這近似值我們叫做 DOF,OK,好,好,這樣子我好像比較可以理解,呃,不,對對對,所以 alpha ij 其實可以取任意值,他可以是,呃,他其實就是訊號強度的 dB 值啊,

279
01:33:35,020 --> 01:34:04,740
你可以是10,你可以是 100,可以是負十這樣子,負十就是負十 dB 是0.1的意思,嗯,嗯,對,他就是代表很小,他可能比 noise 還小,這樣,嗯,他可以取,或是0.或是 alpha ij 可以是0.01,或是 pi 或者是使得,呃,使得,哦,我覺得你現在這個東西其實是 compare to 那個 z,對不對?就是你的 dB 其實是 compare to 那個 z,

280
01:34:06,020 --> 01:34:31,500
呃,對,沒錯,就是 compare to z 的,呃,這個 z,就是這個,呃,應該說這個 z 是他的 noise,noise,noise 的功率,就是你把 z 的什麼,那叫什麼?呃,z 是 3 noise,z 的那個平均大小大概是 1,然後,noise power 是 1,ok,ok,ok,對對對,我們把它假設成 1 的狀況下,那為什麼可以做這樣的假設?

281
01:34:31,500 --> 01:34:59,660
當然我們背後我們有一些理由啦,就是我們可以去,呃,normalize 啊,或怎麼樣,怎麼樣,怎麼樣,就是在傳送端之間有些 normalize,normalization,然後最後我們可以把問題簡化成,ok,我的傳送的,這個傳送的訊號的功率是最大就是到 1,然後,然後他的那個 noise 是 1 這樣子,noise 的功率是 1,好,這樣我比較理解,不過我,我還有一個問題就是說,

282
01:34:59,660 --> 01:35:24,060
為什麼可以忽然之間從那個,就是從 binary 的變成一個,傳一個時數的,ok,ok,這個,等一下,這比較困難回答,沒有,這個還好,還是說,其實你就是把 binary 想呈現一個時數嗎?還是這樣,ok,他其實是這樣,就是,呃,這個是,這個比較像是我們真那個什麼真正要碰到真正要面對的問題,

283
01:35:24,060 --> 01:35:53,660
就是我假設我,我用電話線去傳,然後我的 signal generator 可以是送任何時數出去嗎?對不對?然後在接收端的時候,我的 noise 也是任何,任何的時數,他可能是服從高次分配,那所以我受我收到了 y,就是我原本傳的訊號加上 noise,他高次分配的,那是高次分配的 noise,常態分配的 noise,那在這種情況下,那我應該要怎麼去設計我的 codebook,我要怎麼設計我的 decoder?

284
01:35:54,140 --> 01:36:15,820
才能夠讓傳輸的速度最大,還有我的傳輸速度最大是多少?這是我們真正要面對的問題,但剛才的那個 0 1 啊,呃,ok,這個 0 1 啊,呃,ok,這個 0 1 啊,只是做了做簡化,為什麼呢?我可以把他設計成 0,我可以把他講成是 0 1 呢?

285
01:36:15,820 --> 01:36:35,240
我覺得有點像是說,我在一般的電話系統裡面,雖然我發出去的都是時數的訊號,對不對?但我在前端,像剛剛的電話,不好意思,我以為電話裡面設的都是 0 1 不是嗎?

286
01:36:35,240 --> 01:37:04,960
沒有,古早的電話,古早的那個那個以前還有那個什麼人工托接,人工要 switch 的時候的電話,那些都不是,那些都不是 0 1 啊,現在的電話是,那那不是,我覺得你可以不需要想像那個電話,你就想像就是你拿著一個紙杯,然後上面有一條繩子,然後另外一端有人拿那個紙杯,然後你在講話,然後如果連那個線傳過去,然後那個人就會聽到你的這個聲音,但是加上一個 noise,然後這個就是 describe 那樣的訊號。

287
01:37:05,240 --> 01:37:35,200
對啊,對啊,那就是是啊是啊,呃,不好意思,那我可不可以換個方式解釋,因為其實這聽起來學點比較像是 modulation 的概念,因為如果你送一個 bit,那你當然可以用正一負一去送,但如果你想要送兩個 bit,你可能就要有四種組合,才代表這兩個 bit 嘛,那我們可能簡單選擇就負三負一正一,呃,正一跟正三,那以此類推,所以代表說如果你送的更多 bit,其實你轉換過去一個 modulation,我們通常叫調變,就 modulation 這個情形,會把它變成一個

288
01:37:35,740 --> 01:37:56,540
時速的訊號來代表你某一個某一個 bitstream 組合,所以果然說你送兩個 bit,那你有00111011四種組合,那你就會有對應成負一負呃,負三負一正一正三,所以它就轉換成一個類比的訊號,呃,就是時速訊號,這樣可能會比較好理解說,為什麼我們從 digital 其他 modulation 調變過,它還是一個時速。

289
01:37:56,540 --> 01:37:59,540
整理&字幕由 Amara.org 社群提供

290
01:38:26,540 --> 01:38:49,540
整理&字幕由 Amara.org 社群提供

291
01:38:56,540 --> 01:39:00,540
整理&字幕由 Amara.org 社群提供

292
01:39:26,540 --> 01:39:29,540
整理&字幕由 Amara.org 社群提供

293
01:39:56,540 --> 01:39:59,540
整理&字幕由 Amara.org 社群提供

294
01:40:26,540 --> 01:40:29,540
整理&字幕由 Amara.org 社群提供

295
01:40:56,540 --> 01:40:59,540
整理&字幕由 Amara.org 社群提供

296
01:41:26,540 --> 01:41:29,540
整理&字幕由 Amara.org 社群提供

297
01:41:56,540 --> 01:41:59,540
整理&字幕由 Amara.org 社群提供

298
01:42:26,540 --> 01:42:29,540
整理&字幕由 Amara.org 社群提供

299
01:42:56,540 --> 01:42:59,540
整理&字幕由 Amara.org 社群提供

300
01:43:26,540 --> 01:43:29,540
整理&字幕由 Amara.org 社群提供

301
01:43:56,540 --> 01:43:59,540
整理&字幕由 Amara.org 社群提供

