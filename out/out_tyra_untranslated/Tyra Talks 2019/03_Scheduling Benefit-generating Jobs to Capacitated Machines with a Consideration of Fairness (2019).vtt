WEBVTT

00:00.000 --> 00:13.320
好,那歡迎來到今天的 Taira Talk,今天是2019年2月16號,我們請到的講者是孔令傑教授。

00:13.320 --> 00:40.320
孔令傑教授是國立臺灣大學資訊管理學系的副教授,他之前是在美國伯克萊讀博士,然後在臺灣大學讀學士和碩士。

00:40.320 --> 00:49.320
研究方面主要就是賽局理論和作業研究,然後對於商管領域的決策問題做探討。

00:49.320 --> 00:58.320
我們很高興今天歡迎到孔教授,那我們就請孔教授開始吧。

00:58.320 --> 01:08.320
孔令傑教授,我們先鼓掌,歡迎孔教授!

01:28.320 --> 01:40.320
這次的機會真的是很難得啊,因為我個人在念博士或者是開始教書以後都很喜歡去聽各式各樣奇怪的talk,所謂奇怪就是跟自己的領域不大一樣的。

01:40.320 --> 01:58.080
從某個角度來講,對我們這種人是很需要的,因為我們念的是資訊管理嘛。資訊管理,先跟大家簡單介紹一下好了,就是我們在管理學院學資訊技術,想要用資訊技術看能不能幫管理這個領域做一些事情。

01:58.080 --> 02:14.080
基本上呢,它本身就是一個跨領域的領域,所以我們經常去聽一些各式各樣奇怪的talk,就可以得到很多各種啟發,有時候完全沒有啟發也沒關係,就當作增廣見聞囉。

02:14.080 --> 02:25.280
所以以前念博士的時候啊,剛剛介紹的傑森大大就常常跟我介紹一些物理相關的知識,雖然我也是幾乎全部都忘光了啦,不過對於這個交流還是都覺得很開心。

02:25.280 --> 02:35.080
那今天就用這個機會來跟大家介紹一下我的研究領域,那這當然是其中一個研究,不過我個人還挺喜歡的。

02:35.080 --> 02:58.080
它是一個我跟我以前的碩士班學生叫劉奇偉做的,那這個事實上是他的碩士論文,然後當然過程中我們就是一起把它做出來,就結果來說我覺得這個研究在學術的成果上還是蠻不錯的,所以台大的碩士生或者是說認證的碩士生確實是可以做到蠻不錯的成果。

02:58.080 --> 03:13.080
好勒,那這個研究是幹啥的,這個研究的主題叫做Job Allocation with the Consideration of Fairness,就是考慮公平性的工作分配問題,那我們來看看這是幹啥吧。

03:13.080 --> 03:41.580
今天呢,當我們要做工作分配的時候,通常要考慮很多議題,那比如說就假設Job是所謂的做玩具車好了,那一般的情況下就是我是一個worker,我把玩具車做出來,假設我做一輛玩具車要兩個小時的話,把它賣給buyer,就是消費者,那buyer就會付我錢,所以工作就是花時間做東西出來,賣掉換錢,就這麼簡單嘛。

03:41.580 --> 04:07.580
那今天呢,我們之所以會一開始會討論,這個大概從我回來台灣的那一年就開始遇到這個題目,就是那個時候,因緣際會的遇到一個在竹科,有五六座晶圓廠,然後在這個南科啊,中國啊,都有許多廠,不是晶圓廠對不起,做LED chip的公司,那這個公司遇到的問題是這樣,

04:07.580 --> 04:36.580
他的客戶會跟他下訂單,比如說這個訂單是說我要一百輛玩具車,或是我要多少多少個LED chip,那公司的owner就要負責把工作分配給各個工廠,那分配工作的時候呢,就會發生一個所謂的公平性的議題,就是每一個工廠都想要爭取所謂的比較好做的訂單來做,那有的訂單呢,他的workload,

04:37.580 --> 04:59.580
也就是你要花的時間很長,然後呢,benefit,就是毛利,或者是這個容易賺錢的程度又很低,比如說生產一些相對傳統的東西,那這種利潤又小,然後這個做起來又花時間的,這大家就不喜歡,然後或者是比如說做的時候良率很低啊,很困難的,大家也不喜歡。

04:59.580 --> 05:16.580
所以大家,這些工廠的廠長們都是以最後都是要被review的嘛,那大家就會,他們真的會發生,他們會去跟公司的頭頭,就是拍桌子大罵說為什麼這個單分給其他人不分給我,這樣子的議題。

05:16.580 --> 05:32.580
好,所以從那個時候開始,我就意識到,當這個工作分配這件事情發生在人與人之間的時候,他確實會遇到一些有趣的議題,是傳統的工作分配上不會遇到的。

05:32.580 --> 05:56.580
傳統的工作分配通常一開始啊,不管是職工的人,或者是公共的人,他們在講這個工作分配,比較常是我把工作分配給機台,或是分配給CPU,那他們自然就沒有什麼公平不公平的問題,大家都乖乖聽你的話嘛,但你把工作分配給人的時候,人一定會care公平,

05:56.580 --> 06:20.580
他們除了care自己的工作量,自己的報酬以外,還care自己跟別人比起來怎麼樣,大概是這個樣子。那所以,everybody wants to earn more money嘛,那因此呢,在剛剛那個實務問題,motivate我們去做這個study了以後,我們慢慢的就是把它劃減,劃約成一個以下的題目。

06:20.580 --> 06:48.580
也就是說呢,我們會有很多工作,每一個工作會有它需要耗的時間,以及這個工作做完可以賺多少錢,比如說做這個小車車,它需要兩個小時,然後可以賺這麼多錢,那做這個中車車呢,需要2.5個小時,可以賺的錢比較多,那大車呢,這個最高級的,要做4.5個小時,可以賺最多錢,所以呢,工作會有各式各樣的,那有的比較難做,有的比較賺比較多錢,這樣。

06:48.580 --> 07:04.580
然後我們有許多所謂的工廠,那他們的capacity,也就是說他們每一個工廠可以負擔的工時,是有限的,你不能把所有的工作都分給同一個工廠,那麼在這樣子的問題下,我們想要做工作分配。

07:04.580 --> 07:33.580
那大家可能會想,有沒有什麼其他的情境下,也要做這種工作分配呢?其實還蠻多的,那這裡舉幾個例子,這幾個例子都是後來陸陸續續看到的,那第一個例子是這個高雄港,高雄港是一個我們現在有在討論,有在從事的project,那高雄港大概是這個樣子,我們討論的是這個所謂的引水人,那假如大家不大知道引水人的話,有興趣可以去google一下,

07:33.580 --> 08:02.580
就是查得到引水人是做什麼的,大概是這樣,假設今天有一條船在這裡,好,這條船呢,想要進來高雄港,然後這樣子停,那我現在畫的路線,這個是二號港,這個地方是一號港,那一號港比較靠北邊,所以這裡是山多商圈這個附近,那這個地方大概是小港這個樣子,那這邊這一條就是大家可能都去過的奇景,好,總之呢,這一條船現在想要進來的時候啊,

08:02.580 --> 08:26.580
他不能直接進來,他必須要在大概這個地方等待引水人上去,引水人就是一些住在碼頭附近的地方的這個資深的船長,那他們以前都有很多年的帶船到處跑來跑去的船長經驗,然後後來呢,轉職成為引水人了以後,他們就會住在港口的附近,

08:26.580 --> 08:54.580
當有船要進來的時候,引水人就會在外海,就會搭著小艇到外海去暫時接管這一條船,跟那個船的船長一起把船開進來,那之所以需要引水人,當然是因為一個港的水文,當地的人比較了解,所以這些高雄港的領港或者是引水人,他們就比較知道這個高雄港的狀況啊,然後高雄港裡面的這個航務的設定啊等等的,

08:54.580 --> 09:20.580
所以呢他就可以把船這樣帶進來,那帶出去也是一樣,然後船在碼頭之間移動也是一樣,都需要引水人,那以高雄港的規模來說,高雄港一年大概有四萬條船進出,然後有四十個引水人,那他們很明顯的就是這一年來的這所有的工作,就要分給這四十個引水人來做這樣子,

09:20.580 --> 09:36.580
那平均每天有一百多條船,然後就一百多條船進進出出進進出出,分散在二十四小時之內,那這些引水人就要去把他們依序做完這樣子,那這裡為什麼會有所謂的公平性問題?

09:36.580 --> 10:06.240
呃,一條船進來,一個引水人去帶,那有的船很難帶,就比如說載著油的船,載著危險物品的船,或者是超級大的船,這種船很難帶,那有的船很簡單,然後呢進港比較麻煩,出港很容易,大家就想像路邊停車啊,路邊停車當然是開出去馬路容易,停好很困難嘛,所以很明顯你工作有簡單跟難的差別,因此就有獎金不一樣。

10:06.240 --> 10:36.220
那引水人呢,他每帶一條船就會得到一些獎金,那少的幾萬元,多的幾十萬元,這個金額是很驚人的,差的也很多,所以對引水人來說,他們如果要工作分配的話,他們最關心的其實不是,呃,操勞的程度啊,或者是我跟航商之間的關係啊,這些他們都考慮,可是他們最考慮的,或者是說不能忽視的一點,就是這些工作到底,

10:36.220 --> 11:05.980
分的公不公平,就不能每一次我去做都是做一些賽缺,然後做一些很難做,薪水又相對少的,然後每一次好了都分給他,這樣子就不行嘛,所以這是一個工作分配的例子,我分工作,大家要吃得下,要做得完,不能危險架勢的同時,我們還要顧慮到大家的這個,呃,所謂的賺的錢不能差太多,或是不能相對於他的工作差太多。

11:06.220 --> 11:36.200
那很類似的就是比如說按摩店,好的路邊啊,會有很多,不管他是盲人也好,不是也好,或者是這個就是專門幫你按摩放鬆,然後這個讓你下班以後可以輕鬆一下的這種按摩店,按摩店一般來說也是你走進去,就相當於是一個工作,然後裡面就有一堆按摩師傅嘛,那通常就是有幾個人在輪班,所以他們就要分分分,那有的店他會用完全就是輪流的方式,那輪流的方式的話呢,可能好,可能不好,

11:36.220 --> 12:03.240
不過也一樣,他一定會遇到就是公平性問題,就是你不能每一次操的工作都給同一個人做,然後要爽的都給另一個人做,這樣。那最後,還有所謂的社會企業,呃,社會企業這個詞的意思大概是說,這家公司成立的目的是為了要增進社會的福利,而不是他公司自己要賺最多錢,好。

12:03.240 --> 12:32.280
那以臺灣來說啊,有一個,就只舉一個例子就好了,就是有一個公司,他叫大智文化,那他呢,基本上就是賣所謂的大智雜誌,就是叫做big issue,那這個也不是臺灣獨有的這樣子,他的特色就是,他是把報章雜誌,就是這個大智雜誌,好,他是交給,呃,遊民,讓遊民去賣這樣子,那這個機制本身不是重點,重點是。

12:32.680 --> 12:46.720
你既然是把這些工作交給所謂的遊民,那你當然目標就是希望遊民們都可,每一個遊民都可以賺到一定程度的錢,而不是要最大化公司的總利潤,好。

12:46.720 --> 13:13.740
所以在這許多的例子裡面呢,我們都可以看到,基本上是有一個人,他手上,他是一個中央控制的單位,他要負責分配工作,那傳統的分配工作都是,我有一些手下,我就分工作,他們就會乖乖聽話,然後他們聽完話了以後,他們就會把工作做完,那我們就有利潤,有報酬等等,然後我最大化我個人的總利潤。

13:13.940 --> 13:34.180
那以前是這個樣子,不過在某一些題目,例如在我們考慮的這個題目裡面,大家也可以看到,很多時候工作分配,關心的其實不是總體效率,其實是公平性,那如果是這樣子的話,那可能就需要新的方法,或者是需要調整舊的方法,大概是這個樣子。

13:35.180 --> 14:02.160
那麼,嗯,以這個剛剛的題目來講啊,job這個東西可以說是令人又愛又恨,他一方面來講就是你做工作要花時間,可是他又是珍貴的資源,因為做工作是有錢賺的,好,那所以呢,我們要使用好的方法,把job分給我們的這些,呃,工作單位,那我們在字面上還是會稱這些工作單位為machine,好,

14:02.160 --> 14:30.700
因為在這個排程,scheduling這個領域裡面,大家都是這麼叫的,就叫他machine,不過我們自己知道,我們所謂的machine在這裡更像是agent或者是員工這個樣子,好,所以呢,我們不只考慮,我們我們主要不是要考慮最大化總利潤,主要是要考慮公平性這樣,那麼我們的machine會有所謂的limited capacity,就是你一個人嘛,一天的工作量是有極限的,

14:30.700 --> 15:00.000
所以你不能夠做超過你的負荷量的工作,那麼呢,我們在這個地方的setting是,只要你還有enough capacity,那你就會想要多做工作,好,就像按摩師傅或是飲水人一樣,就你今天在值班,然後呢,只要你的工作量可以負荷,你就想要多做一點,多賺錢,大概是這個意思,然後呢,我們假設工作不能被split,

15:00.000 --> 15:29.980
那這個是看情況的,不過以我們剛剛講的例子裡呢,按摩師傅通常他的工作是不會被分割的,就你進去有一個人幫你腳底按摩,或者有一個人幫你放鬆肩頸,他不會放鬆肩頸到三分之二的時候忽然換下一個人,對吧,通常都是這樣子,那高雄港那更不用講,他從外海幫你把船帶進來停好,他不會中途換一個飲水人,這樣子就是非常之浪費時間,好,所以我們在這裡都假設job是不能被分割的,

15:30.000 --> 15:59.980
那有一些情況下當然可以,比如說有一個客戶跟我下訂單,他想要一百輛玩具車,我當然可以分給工廠A跟工廠B,各做出四十輛跟六十輛,對吧,那不過在實務上呢,有一些時候公司也不想要這樣子分割訂單,因為很明顯就會造成一些作業上的困難,他們煩惱,好,那再加上學術上,我們可以很容易的證明,如果這個問題的工作是可以被自己做的,

16:00.220 --> 16:27.980
可以自由分配,而且沒有成本的話,那這個問題就有很既有的方法可以很輕易的解出來,所以不管從實務的角度還是從理論的角度都支持我們,就是做這個設定,就是在某些情況下工作是不能被分割的,那我們也會就這個論點去討論,所以我們這個問題的總體目標就是我想要最大化這個所謂的minimum benefit among machines,

16:28.160 --> 16:51.200
那這個東西是我們這個題目的一個核心的setting,所以讓我們來講一下為什麼我們要做這件事情,呃,基本上問題可以來,呃,我對那個不能分割這個假設啊,會導致就是說,因為你剛剛說如果可以分割的話就可以很容易被呃,就解出來,

16:51.200 --> 17:19.980
所以你的意思是說,比如說可以任意分割到無限小的話,基本上就是一個除法的概念嗎?你就把它總共多少除以多少個agent,然後就這樣,哎,這樣嗎,比那個稍微再複雜一點點,好,就是我們今天這個,嗯,嗯,呃,我的先從技術的角度來講的話,呃,我們待會會展示數學模型給大家看,

17:19.980 --> 17:48.620
所以大家會看到我們會是一個整數規劃問題,那如果今天工作可以分割,它會變成線性規劃問題,那線性規劃問題已經有,嗯,人人都可以接受的好的方法來解決,好,所以這是一個比較學術上的回答的方式,那您剛剛的講法就是所謂的它都除下去就好了,類似類似,好,雖然不是一個很不一定總是可以得到最佳解,

17:48.620 --> 18:04.620
不過差不多就是那個概念沒有錯,所以就是,如果今天job可以任意分割,然後到無限小,然後沒有成本,想分幾分就分幾分的話,的確這個問題就不需要被研究這樣子。

18:05.620 --> 18:25.320
整數學模型的解釋,我現在有開嗎?哦,我開了,開了,哎,我這樣聽得到嗎?有,哦,OK,所以好,那我還有另外一個小問題,就剛剛那個我了解了,那另外一個小問題就是如果有這個假設的話,就是聽起來是還是你,你接下來還是會用算的嗎?

18:25.320 --> 18:38.580
還是會變成說就變成要丟一些,比如說像數值模擬啊,然後他跑一些什麼money color之類,然後看一些統計分佈的結果,還是你們還是會趨向是要算結果的?

18:39.580 --> 19:08.220
哎,對啊,呃,OK,對啊,因為你剛才講,OK,好,好的,就是這樣,好,謝謝,對,謝謝,對,沒有錯,就是我們要算結果,這個這個study基本上是一個作業研究的study,就是如待會大家會看到的,主要的任務是寫一個數學模型來描述這個問題,以及幫他寫一個演算法,哦,那呃,您剛好提到money color啊,這個數值模擬等等的,因為我們這個問題待會大家會看到,

19:08.220 --> 19:34.700
我們是一個deterministic的問題,所以呃,倒是不需要使用這些,呃,統計分佈啊之類的,他基本上就是一個標準的演算法問題,不過待會會提到,那我們就待會再看,那到這一行以上,基本上是講我們這個題目的setting,我們有一堆job,我們有一堆所謂的machine或是agent,然後呢,我們考慮agent關心的所謂的公平性,

19:35.060 --> 20:02.860
那公平性需要一個measurement,就是我們在分配工作,他們賺錢了以後,我們需要measure所謂的公平性,那measure公平性有很多種做法,比如說啊,有學術上有人是這麼做的,就是大家都有賺錢,那最賺錢的人,那個人不要賺最多,不要賺太多,或者是賺最多的人跟賺最少的人不要差太多,

20:03.340 --> 20:29.260
或者是每個人賺的錢的variance不要太大,之類的,所以你可以寫出很多目標式,比如說我minimize maximum benefit,意思就是說,我有十個人,然後每一個人都有賺錢,那十個人之中賺最多錢的人,看他是賺多少錢,我來最小化他賺的錢,或者是我minimize maximum benefit

20:30.140 --> 20:56.940
減minimum benefit,這樣子,就是有一個人賺最多嘛,有一個人賺最少嘛,然後我們來最小化這個差距,或者是我來minimize variance of benefit,這樣也可以,對吧,那這些東西都ok,不過在我們這個題目裡面呢,如果我們選用這一些目標式的話,

20:57.100 --> 21:25.100
那我們要同時處理fairness跟efficiency,就會很麻煩,為什麼,因為我們如果用這些目標式的話,那最佳解都會很自然地變成,所有的工作都不要做,那都不要做,全部的人都賺零塊錢,這個也是最棒的,這個也是最棒的,這個也是最棒的,所有的目標式都被你optimize到不能再被optimize,但是efficiency是零,

21:25.100 --> 21:54.220
就會變成說,我們必須要用其他的方式來限制,我們不能完全放棄我們的這個總體efficiency,所以我們最後呢使用的這個目標式是這個,就是我工作分給大家,大家都有賺錢,我看哪一個倒楣鬼賺最少,我來最大化那個倒楣鬼所賺的錢,那如果是這樣子的話,首先就是最窮的人不會太窮,最衰的人不會太衰,

21:54.220 --> 22:19.260
那這個蠻符合我們的這個某種公平性的intuition,那其次就是,如果你希望盡可能地最大化賺最少的錢的那個人的錢的話,那自然其他人也不會賺的比他多很多,因為這樣子的話,這個目標不會被滿足,那最後就是,如果我的目標是最大化minimum benefit,那事實上我們最後會show給大家看,

22:19.340 --> 22:38.460
總體的efficiency就不會差太多,我們可以同一個問題,我maximize efficiency或是maximize fairness,我們用這個setting來maximize fairness的話,那efficiency也不會差到哪裡去,大概是這樣,所以我們這個問題就會以這個目標來出發。

22:39.420 --> 23:07.740
那我們今天,呃,因為呃,我們assume大部分的這個朋友們都不是做所謂的作業研究這個領域的,那所以我們當然是挑比較精,嗯,怎麼講呢?比較比較容易理解的部分來講,哦,所以我待會還做幾件事情,我會把這個problem的formulation寫下來,也就是說用簡單的數學式子,我們來精確的定義一下。

23:07.860 --> 23:34.300
我剛講的事情,那有了一個model了以後呢,他會允許我們證明他np hard,那np hard是一個cs或,呃,就是computer science或作業研究領域的人會使用的詞彙,那大概的意思就是我要證明一下這問題很難,哦,難道我們沒有辦法期待自己可以在合理的時間範圍內求得最佳解。

23:34.580 --> 23:51.300
那因此我們就會去design一個所謂的heuristic,也就是說,哦,這問題這麼難,那找不到最佳解,那我們就找一個可行解吧,然後我們來看看這個可行解,我們來分析一下它的效能,大概是這個樣子。

23:51.300 --> 24:21.260
那分析效能這件事情是,呃,怎麼講呢,也是很困難的,哦,所以我們只會挑我們這整個研究的其中一小部分,就是最容易理解,但是也最精華的那個部分來跟大家分享,也就是說,同樣一個問題,你也可以設計演算法,我也可以設計演算法,他也可以設計演算法,這個演算法很容易啊,那可是我們想要做的事情就是去找找我們的演算法的理論性質,看看它可以好到什麼程度,或者是差到什麼程度。

24:21.300 --> 24:51.100
哦,hopefully,這樣子可以讓我們對演算法的認知多一些了解,大概是這樣子吧。好,那我們就來formulate一下這個problem,呃,我們這個領域叫作業研究嘛,operations research,那他一開始的時候是大家小時候都學過的線性規劃,就是linear programming,線性規劃大家如果完全沒有印象的話,以前小時候大概會做類似這種事情,就是你有x跟y。

24:51.340 --> 25:19.540
然後呢,他們被限制式放得住,也就是說,比如說,x加2y,呃,對不起,這是2x加y,然後小於等於6啊,然後什麼x加2y,然後小於等於4啊之類的,所以你就會有一個feasible region,x大於等於0,y大於等於0之類的,然後呢,你suppose會有一個目標式,比如說,我要maximize x加y,這樣,那你就會有一條線,往這邊推,然後你就得到最佳解,好,這東西是線性規劃。

25:19.820 --> 25:42.420
那大體上來說呢,作業研究方法就是,我把問題試著寫成線性規劃,非線性規劃,整數規劃等等的,然後我們就用各式各樣的方法來求解,好,所以我們現在就要來做一件類似的事情,我要來define我的decision problem裡面的目標式,限制式,還有決策變數。

25:42.900 --> 26:11.060
那我們就回憶一下我們剛剛說的題目,我有一組人,agent或是machine,是我的工作單位,然後我有一組job,是我要分的,然後呢,我今天呢,小n是我有幾個job,小m是我有幾台machine,所以m是machine嘛,那另外一個符號n就是job,這樣子,然後呢,我每一台machine都是有極限的,

26:11.220 --> 26:34.780
我一個人一天工作八小時,這一類的,所以呢,我工時有上限,這個叫做k,叫做capacity,每一個job都有它需要的工作時間,所以叫做cj,那這個在scheduling的literature裡面通常叫做processing time,就是這個工作要搞多久才能做完。

26:35.300 --> 27:03.980
然後jobj,jobj呢,有它的benefit,就是做完了以後,我可以得到多少錢,這個樣子,那我們的任務就是決定所謂的xij,xij是一個所謂的01變數,它呢,就是對於每一個job和每一個machine,我問我自己,我有沒有打算要讓machine i來做job j,

27:04.220 --> 27:19.620
如果有的話,表示我把j分配給i,那我就把它的值設成1,不然我就設成0,大概是這個樣子,那有了這個決策變數了以後,我們來看看我們要怎麼描述我們剛剛講的那些目標式啊限制式啊之類的。

27:19.620 --> 27:49.580
這個問題描述起來很簡單,我們先看底下這裡,第一條式子是說,對於每一個機台或是每一個agent,我分配給它的總工作量不能超過它的工時上限,那怎麼說呢,xij等於1的話,表示我把j分配給i嘛,所以對每一個工作我都問,我有沒有把j分配給這個i,如果有的話,那這個工時就要累加起來。

27:49.900 --> 28:15.140
所以我得到的總工時不能超過我自己能負荷的量,這是限制式1,那限制式2是說,每一個job都是分給最多一台machine,這樣子,所以我看著我所有可能被分配的machine,xij最多只能只有一個人,是1,這樣子。

28:15.380 --> 28:43.100
那這裡,xij我們設定它不是0就是1,不能是0.3啊0.8啊之類的,那這樣子表示這個工作是不能分割的,那最後是目標式,目標式在這裡,我想要最大化所謂的minimum benefit,那怎麼說勒,對每一個i,每一個machine來說,我就去算,我得到多少benefit。

28:43.100 --> 29:12.740
xij如果是1,表示我得到那個job,那我得到那個job,我把它做完,然後我就得到這個benefit,所以大瓜湖裡面,就是machine i得到的benefit,那你賺8塊,我賺5塊,他賺16塊,我們之中最倒楣的人是5塊,那這個目標式值就是5,我想要最大化,賺最少錢的人所賺的錢,大概是這個樣子,那麼這個地方啊。

29:13.100 --> 29:42.740
有幾個式子,呃,就是在這裡,我們把它複習一下,我基本上是maximize minimum total benefit among machines,然後第一條是capacity constraint,就是我的工時是有限的,那第二條是job can be done only once,所以就是一個job只能被做一次,只能分配給一個人,然後最後就是job不能被split,大概是這樣,那這裡先跳出來講幾件事情,呃,我們這裡有幾個setting。

29:43.100 --> 30:11.740
bj,cj和k,這裡等於是假設,每一台machine都是一模一樣的,所以他們的工時限制是一樣的,然後呢,每一個job都是,呃,每一個job分配給你或分配給我,得到的利潤是一樣的,然後每一個job要做多久是一樣的,那這些setting有些時候成立,有些時候不成立,比如說。

30:13.180 --> 30:39.700
k好了,k這個東西呢,如果今天講的是,比如說按摩師傅,那就不一定了,有的人搞不好一天可以做8小時,有的人一天只能做4小時,對吧,那今天bj,bj是做一個工作可以跟客戶收多少錢,這個可能就一樣,按摩師傅嘛,但這個一個人進來,然後你按也是400塊,我按也是400塊,ok,那cj也不見得一樣,呃,不,不一定一樣或不一樣,比如說。

30:39.700 --> 31:09.100
按摩師傅通常都是一個工作,就是腳底按摩30分鐘啊,肩頸20分鐘啊之類的,好,所以那cj自然就會相同,但是如果今天是,比如說飲水人飲水,有的人技術比較好,贏的比較快,有人贏的比較慢,這個就有可能,那不過,學術上呢,事實上我們之前有做過了,k你可以把它變成每個人都不一樣,這個ok,cj你可以變成cij,bj你可以變成bij,好,只要滿足某一些合理的設定。

31:10.020 --> 31:38.660
那這個問題還是有辦法處理,那不過今天因為時間的限制,我們就不講那麼多,我們就直接假設bj大家都一樣,cj大家都一樣,所謂大家都一樣,是分給你或分給我,我們賺的錢都一樣,是那個意思,然後最後k大家都一樣,我們就假設這件事情,然後啊,呃,剛剛有提到,這工作如果可以分割的話,那這個地方限制式就會變成xij,

31:39.020 --> 31:55.460
介於0到1之間,那這個時候呢,這個問題,你就可以再多動一點點手腳,它就會變成linear program,就變成線性規劃,那線性規劃就會就是一般的commercial solver都可以把它解出來,那這個問題就沒什麼好研究的了,好。

31:56.300 --> 32:25.020
那麼今天,呃,這也有來把它跳過,好,所以今天呢,有剛剛那個問題了以後,在我們這個領域,首先我們就是要證明這個問題是NP-hard,NP-hard的意思,當然這個細節我在這裡就不講了,不過它的意思大概就是,如果你能證明一個問題是NP-hard的話,表示學術界的人基本上都公認,這個問題在合理的時間範圍內是求不出最佳解的。

32:25.340 --> 32:46.780
也就是說,這個問題的複雜度很高,大概是這個意思,好,那剛剛那個問題啊,就是如果大家不是做這個領域的,可能很難想像為什麼它的複雜度會很高,好,為什麼求得最佳解會很困難,那我們就稍微描述一下這個證明,那這個問題是這樣子。

32:47.500 --> 33:14.900
我今天呢,假設我剛剛那個問題變得簡單一點,好,一個special case,這個special case裡面事實上只有兩台machine,而且這兩台machine是uncapacitated的,表示它們的工時是無限大,或者是遠大過這個所有的工作量,這樣子,那我們在這個情況下呢,我們的問題會變成所謂的partition problem,什麼意思,就是我的工時已經無上限了嘛,

33:15.060 --> 33:42.020
所以那個工時的限制已經不存在了,我只關心這一堆job,它們會需要多少的,會得到多少的效益,工作一可以賺三塊,工作二可以賺四塊,以此類推,然後我的公平性問題無非就是,我要把這一堆benefit,盡可能平均底分給兩個人,對吧,最好是這樣疊起來會一樣高。

33:42.220 --> 34:11.260
那這個問題在數學上,或是在計算機科學,叫partition problem,就是我給你一堆整數,你把它分成兩堆,想辦法讓這兩堆一樣大,這樣子,那這個問題事實上就是NP-hard,就是只要你數字夠多,這個問題就找不到好答案,你就分啊,你就分啊,但你分不出來,然後甚至就連你連判斷它們能不能分成一樣大的兩堆,都是辦不到的,在合理時間內都是辦不到的。

34:11.540 --> 34:32.540
所以連partition都辦不到,那我們的問題是比partition更難嘛,就是更加也做不到,大概是這樣子。好,那既然如此,那我們就來找一個heuristic algorithm,那這個東西就是我現在,嘿。

34:32.540 --> 34:36.540
我有個問題,可以回到上一頁嗎?

34:36.540 --> 34:58.540
嗯,就是,但是你要處理的問題是你只要maximize的minimum benefit,你不一定要是partition,那這個情況還是一樣是NP-hard,就是你可以完全對應到這個partition的problem。

34:58.540 --> 35:26.940
欸,問得非常好,這個,我們在maximize minimum benefit,這樣,所以我們in general是做這件事情,但是當我們只有兩台machine的時候,我們就會變成,呃,想要讓它們盡量一樣大,對吧,對,如果我們沒辦法讓它恰好一樣大,那這個東西in some sense就,呃,不公平,或者是我們

35:27.340 --> 35:31.500
對能夠maximum minimum benefit的方式就讓它們兩個一樣大,這樣。

35:32.860 --> 35:34.220
這樣有回答到很多問題嗎?

35:34.220 --> 35:53.980
但是你有可能就是,那件事情,欸好,沒事,我知道了,我知道了,對對對,好,那我修正一下,這個partition problem,它有兩種版本,版本一就是我給你一堆數字,問你能不能把它們分成恰好一樣大的兩堆。

35:54.140 --> 36:01.660
版本二是我給你一堆數字,你幫我最小化這兩堆數字的差,這樣子。

36:01.660 --> 36:22.780
OK,然後這兩個問題都以證明NP-hard,OK,對,好,那事實上版本一還比較簡單,版本一是decision problem,就是是或否,版本二是optimization problem,你要找出一組分配方式,那我們的問題是版本二的擴充版,這樣子。

36:22.780 --> 36:52.740
嗯,OK,好,好,感恩,好,然後接下來,欸,到這裡了,好,所以今天,呃,我們基本上是不打算找最佳解的,那我們呢,會找所謂的可行解,用heuristic algorithm,那heuristic在中文翻成啟發性演算法,它其實就是一種經驗法則,就是,呃,我這裡有一大堆數字,怎麼分比較好呢?嗯,不知道,不過不如就這樣分吧,通常都還不錯。

36:52.780 --> 36:53.000
好,大概是這個感覺,那heuristic演算法從學術的角度聽起來很廢,就是,它如果就是一個很很簡單的rule-based的演算法的話,大家就會覺得,哇,聽起來好像很簡單,這樣真的可以嗎?但其實實務上幾乎都是這麼幹的,呃,以高雄港那個例子來說好了,我們在跟他們討論的時候就說,哦,那好,聽起來是一個工作分配問題,那我們就來design演算法吧,那講了講了講了一陣子了以後呢,就發覺說,哦,那好,聽起來是一個工作分配問題,那我們就來design演算法吧,那講了講了講了一陣子了以後呢,就發覺說,哦,那好,聽起來是一個工作分配問題,那我們就來design演算法吧,那講了講了講

37:22.780 --> 37:51.100
然後發現,他們很擔心演算法會被黑箱,也就是說,有人寫了一個軟體做工作分配,那要是寫軟體的人跟其中幾個領港串通好,然後就很favor那幾個領港的話,怎麼辦?對,就沒辦法解決嘛,所以也就是說,這個演算法如果被implement到飲水人之間的工作分配的話,演算法一定要很簡單,很容易解釋,everybody can understand,

37:51.180 --> 38:20.500
所以今天當一個工作被分給A而不是分給B的時候,調出歷史記錄,調出演算法的文件,一定要能說明為什麼是給A而不是給B,有這樣子的一個要求在,所以在這個情況下就變成,反而不能用太複雜的演算法,你一定要用相對簡單,卻又有效的演算法,所以那什麼類神經網路啊,創殺毀啊,你就不能用,你就是要用相對簡單的演算法,然後還能讓他得到一定的效果。

38:20.900 --> 38:36.020
好,那麼我們就來找一個簡單的演算法吧,那剛剛那個問題如果要design演算法的話,怎麼辦?看文獻嘛,所以就看人家文獻,1966年的時候就有人研究過一個很像的問題,

38:37.020 --> 39:04.940
你有一堆machine,它們長得都一樣,但你是要minimize makespan,那什麼意思勒?就是你有一堆工作,這堆工作都有剛剛所謂的CJ,就是workload,所以每個工作都要花一定的工時,那當時那個問題沒有什麼benefit這種東西,你就是一堆工作分給一堆machine,然後希望最小化,做最久的那一台machine的總工時,這樣子。

39:05.260 --> 39:32.780
好,那所以這個問題呢,就在學術上,是我們類似這種問題的,算是鼻祖吧,然後後來有一個人,Dewar Meyer,他1982的時候做了一個類似的問題,他一樣,工作只有workload,但是他是maximize最爽的那一個人的爽度,也就是說,工作分完,有一個人做最少,我就來最大化他的做的工時,這樣子。

39:32.940 --> 39:51.420
所以,這兩個問題就很像,對吧?就是一堆工作,要花時間,Graham他是最小化做最久的那個人的工時,Dewar Meyer是最大化做最少時間的那個人的工時,這樣子。

39:51.420 --> 40:19.260
但總之都是在工時上面盡可能地追求公平性,那他們用的方法就很簡單,就是說,我們今天他使用的叫做LPT這個演算法,就是我把工作由大到小排序,按照工時排序,然後排完序了以後呢,我們就把大的工作開始分,

40:19.260 --> 40:49.220
每一次要分的時候就分給目前最爽、最輕鬆的那個人,大概是這個樣子,然後分分分分分完就結束了,那這個演算法很intuitive,你每一次都分給最爽的那個人的話,那他目前的總工時是最小的,你分給他當然就會最平衡嘛,然後呢,工作要由大到小排序,這也很make sense,因為小工作最後可以擦空隙,所以呢,我們來看一下例子。

40:49.420 --> 41:18.360
假設我有四個工作跟兩個Machine,四個工作的工時分別是七五四二,然後我兩台Machine空空的,那七五四二已經排序了對吧,所以工作量是七的,我就把它分給Machine1,五的這個時候就要分給Machine2,因為Machine2現在比較爽,他剛剛是沒工作嘛,然後呢,接下來是工作三,工作三就要分給Machine2,因為Machine2目前的工作量比較小,那最後剩下Job2,Job2當然就分給Machine1。

41:18.400 --> 41:20.660
所以那個演算法就是這麼的簡單。

41:22.160 --> 41:44.480
那所以基於他們這個Longest Processing Time的精神,那我們就稍微修了一下,我們就改成Capacitated Highest Benefit Job First,叫做CHBF,這個方法是說,我們今天我們的問題有所謂的benefit,然後我們的目標是均衡benefit嘛,

41:44.840 --> 42:00.840
所以我們把Job由大到小排序的時候是按照benefit排序,OK?好,排完了以後呢,我們每一次要分Job的時候就分給目前的累積benefit最小的那一個Job,我們就分給他。

42:01.200 --> 42:10.200
那分的時候要看他有沒有capacity,capacity如果不夠,那我們就分給第二順位,然後分給第三順位,依此類推。

42:10.200 --> 42:15.600
那一直反覆不斷地做這件事情,直到我們把工作分完為止。

42:15.600 --> 42:29.000
那所謂的分完啊,也有可能是分不完的,因為每一台Machine都有capacity限制嘛,所以有一些Job到最後做不下去,沒得做,也是很有可能的。

42:29.040 --> 42:37.000
那如果一個Job不能分給任何一台Machine,那我們就把它扔了,那這也是沒辦法的事,大概是這個樣子。

42:37.000 --> 42:54.040
好,所以學術上我們可以很容易地分析這個問題的複雜度,但就算你不寫那個式子來分析也沒關係,看得出來很簡單嘛,Job排序,然後接下來就分分分分分分分分分,所以這個方法是很容易可以implement。

42:54.080 --> 43:18.480
那假設今天我們有這個一樣,我們有四個Job兩台Machine,那我們來試一下,這兩台Machine的capacity都是8,最多只能做8個小時的工作,然後呢四個Job分別是9塊錢,然後5小時,6塊錢,6小時,3塊錢,3小時,2塊錢,2小時這樣。

43:18.480 --> 43:47.800
那麼我們首先會把這個9塊錢的工作先拿來分,所以他會先分給Machine1,然後6塊錢的分給Machine2,那接下來是這個3塊錢的要分對吧,3塊錢的照理說應該要分給Machine2,因為Machine2目前只賺6塊,但是想分的時候分不下,因為他capacity吃不了,那他只好分給Machine1,然後最後這個分給Machine2,所以這個演算法大概是這麼跑的。

43:49.480 --> 44:18.440
好,那今天的問題都是這樣子啊,就是隨便給你一個問題,你要design演算法很容易啊,但是你要show他good是很困難的,那什麼叫做good呢?通常有兩種衡量的指標,我把這兩頁講完大概就差不多了,就是說我隨機的給你一千萬的工作,然後你就,呃,我隨機產生這些工作,你就給我排,那排完了以後呢,我們就可以算算目標,

44:18.440 --> 44:48.400
目標是指有多少,對吧?那與此同時呢,我們也可以找一些benchmark的演算法,來大家比一比啊,所以就我們有一百個人,一百個人各自propose一百個演算法,那我們就每次就random instance丟下去跑,然後就看誰的演算法通常表現的會比較好啊,那這就是方案一啦,方案二是我們用比較理論證明的方式去找演算法的worst case performance他的意思大概是說,

44:48.800 --> 45:14.480
針對你propose的演算法,你能不能證明不管是什麼奇怪的instance丟給你,你的performance都可以好到一定程度啊,也就是說我知道我的演算法不會找到最佳解,但是他再壞也壞不到一個程度,大概是這個意思啊,那我們呢,這個所謂的worst case performance guarantee如果能夠找到的話,

45:14.640 --> 45:35.920
他就可以在我們使用演算法的時候給我們一些心理上的confidence,也就是說我也知道我找出來的演算法不見得是,找到了不見得是最佳解,但離最佳解不會差太遠,大概是這個意思,那麼我們在以前呢,

45:36.280 --> 46:05.320
Graham這個Dewar Mayor啊,他們呢,都是有找到所謂的performance guarantee的,以Graham來說,我今天分工作,我要最小化make spend,最小化做最久的那個人的總工時的時候,那他可以證明他的演算法的performance guarantee是3分之4,133%,意思是說,如果最佳解是100的話,

46:05.480 --> 46:34.680
他至少會找到133以下,因為是最小化問題嘛,所以你的目標市值越小越好,他可以保證他的solution跟最佳解最多差3分之1,那Dewar Mayor,不好意思,Dewar Mayor的話呢,就是他的問題是反過來的嘛,所以他變成4分之3,也就是說,最佳解如果是100,Dewar Mayor的solution起碼是75以上,大概是這個樣子,那後來還有一些其他人就有做一些refinement這樣,

46:34.880 --> 46:51.280
那所以我們的目標也是一樣,我們想要幫我們的演算法找到這樣子的一個performance guarantee,那就結果來說當然是有的,我們在各種不同的情境下都有這個performance guarantee,那我們就講一個就好了,就這個。

46:51.280 --> 47:21.240
就是說,如果今天我們的job的benefit跟workload是線性關係,也就是說,一輛車5塊錢,兩輛車10塊錢,三輛車15塊,你做幾個小時,就會線性地得到若干的benefit的話,如果是這個情境,那我們的演算法,我們可以guarantee 2分之1,也就是說,最佳解如果是100,那我們起碼可以做到50以上。

47:21.280 --> 47:51.040
大概是這個樣子,那這裡有一票證明,那這個我就跳過去,那我們要強調一件事情,就是最佳解100,然後你guarantee 50以上,聽起來其實蠻廢的,對吧,那這個時候我們必須要說明一件事情,就是50事實上是最理想的情況,也就是說,guarantee 2分之1是我們這個演算法的極限,什麼意思呢?

47:52.280 --> 48:20.520
假設今天我有很多machine,那這些machine,他們基本上就是,假設我有數個machine,m台machine,然後我有2m加1個工作,其中呢,許多的工作,2m的工作都是剛好一半的capacity,只有一個稍微大一點點,那如果今天是要做這個分配,那麼我用我的演算法,我會先把最大的這個塞進來。

48:20.560 --> 48:49.600
那這一台就會剛好塞不下任何其他工作,其他的machine都會剛好塞2個,塞2個,所以我的solution大概就是最佳解的一半好,那這樣子的話呢,就是在表示說,我們剛剛找到的2分之1,這個solution,這個performance guarantee,已經沒有辦法再更improve了,這個就是極限啦,那不過這個還是沒有辦法回答其他人的一些問題,就是大家可能會想說,2分之1還是很小啊,

48:49.640 --> 49:17.440
就是最佳解是100,你才找到50,這樣真的行嗎?那這個時候我們後面就可以做一些數值實驗,來證明說它事實上in average通常都不會太差,所以像這樣子的研究,在後面都還會做一個numerical study,就是那我們就隨機產生一堆instance,丟給這個演算法,然後呢,演算法to solution了以後,我們再把這堆instance也丟給一個solver,

49:17.680 --> 49:36.160
讓solver去跑個三天三夜找到最佳解,然後來看看我演算法0.2秒跑出來的,跟solver跑三天三夜跑出來的最佳解,到底差多少,那基本上透過各式各樣的調查,大概都是呈現這個關係,在這裡,

49:37.160 --> 50:04.200
也就是說,我們的演算法找到的公平性指標,跟最佳解找到的公平性指標,通常差2%,4%,8%之類的情況,然後呢,在某一些特別嚴謹的情況下,我們的演算法最壞最壞大概是找到90%左右的solution,也就是說最佳解是100,它找到90,大概是這樣子。

50:04.360 --> 50:31.440
然後在相對比較容易處理的情況下呢,它可以找到98%,97%之類的,那這個因為時間也到了,所以細節我就不講了,但大體上來說,我們這類型的研究,做的事情就是像剛剛那個樣子,你有一個問題,以前的人沒解過,那你就解它,你設計了一個演算法了以後呢,從理論性質上,保證它最壞不會太壞,然後用數值實驗說它事實上會相當好,大概是這個樣子。

50:31.440 --> 50:37.200
好,那總結一下的話呢,就是,哎呦,不好意思,誒?

51:01.440 --> 51:16.680
哦,那個講者說他的電腦沒電了,他現在等他一下吧。

52:01.440 --> 52:25.960
那趁這個時間,大家可以想一想,有沒有什麼問題想要問的?

52:32.440 --> 52:48.440
我剛剛有一個沒有很懂,我跟你們討論一下好了,就是如果我沒有理解錯的話,它在generate那些random instances,基本上是完全獨立,然後不相關的,然後看一個分布嘛,對不對?

52:49.440 --> 53:10.440
但是實際上,比如說用飲水人好了,我可以今年先這樣,比如說我先generate一個根據這個guideline出來的解,然後我今年就先這樣排,然後看看狀況怎麼樣,再根據這個狀況去調整明年的排程,然後再調整後年的排程。

53:10.440 --> 53:21.440
所以其實每一個instance應該是會要收斂到更佳的解,而不是無關的,對吧?

53:21.940 --> 53:34.940
你是說那些instance,可能今年度的instance跟下一年度的instance應該有些關係,比如說可能大船總是有50%、小船總是有20%?

53:34.940 --> 53:55.940
就是今年你分了,然後覺得這樣子,看一下最後公平性的每個商家、船家分到的variance,然後用這個作為一個指標來調整下一年的排程,就有點像是你牛頓法的initial guess,然後收斂到更佳的一個過程,它應該不會是一大堆guess都是無關的吧?

53:56.940 --> 54:01.940
對,這個我覺得蠻有意思的,你可以等一下問一下他。

54:03.940 --> 54:12.940
說不定他的這個方法,如果就是做random,他的lower bound不是那麼好,可是他收斂到最佳解的速度比別人都快很多,那不就很厲害了嗎?

54:13.940 --> 54:26.940
你的意思應該是說,如果你對他的instance有一些理解的話,就是你知道工作大概是長什麼樣的話,應該會有更好的解量嗎?

54:27.940 --> 54:49.940
主持人:「我覺得這個好像有兩個問題,一個問題是說,今年的解了,然後看解的誤差有多少再去調整,那這個問題會不會收斂本身就是一個問題嗎?」

54:50.940 --> 54:55.940
主持人:「哦,專家,我從來沒有想過會不會收斂本身就是一個問題。」

54:55.940 --> 55:17.940
主持人:「就是如果這個問題是一個連續的continuous function的optimization,它通常都會收斂,但是continuous加上smooth某一些條件會收斂,但是因為它的optimization好像是離散,然後不continuous,所以很難說會不會收斂。」

55:25.940 --> 55:32.940
主持人:「所以有slide嗎?」

55:55.940 --> 56:14.940
主持人:「是,不好意思,好,回來了,給我20秒。」

56:26.940 --> 56:29.940
主持人:「好,有了。」

56:29.940 --> 56:43.940
主持人:「哎呀,真是對不起大家,我剛剛發現我剛好忘了把筆電的電源線帶來,所以我就急急忙忙地換了一台電腦。」

56:45.940 --> 56:49.940
主持人:「好,總之我們剛剛就講完了,謝謝大家。」

56:50.940 --> 56:52.940
主持人:「拍手嗎?」

56:52.940 --> 57:16.940
主持人:「好,有點搞笑,我還是總結一下好了,總之就如剛剛所說的,基本上這個fairness這個研究聽起來好像很make sense,不過實際上以前出乎意料地並沒有什麼很多人研究過,那大部分的研究都是最大化總體效益,

57:17.940 --> 57:42.940
主持人:「那所以對於這種所謂的一個job,你對他又愛又恨啊,或者是這個agent之間互相要討論公平性議題的,其實討論的蠻少的,那所以這個問題從學術上也有一定的討論價值,畢竟他NP-hard,所以那個好的演算法或演算法的理論價值也是可以討論,那我們大家就做了這些事情,那其實做的也不怎麼樣啦,但就反正就做完了,大概是這樣,好,沒事了,謝謝大家。」

57:42.940 --> 57:56.940
主持人:「好,那我們再次謝謝講者吧,OK,那剛才有一些問題,那要不要來問一下呢?」

58:12.940 --> 58:41.940
主持人:「那你怎麼看這個方法,就是這些方法都,如果你generate一大堆彼此獨立的random instance,你可以看一個distribution,然後說這是lower bound,upper bound,然後distribution怎麼樣,可是比如說就以飲水人的這個例子為例好了,比如說我今天先用這樣的一個guideline去分配,然後今年大家就這樣跑船,可是我可以看今年的結果來作為一個index去調整我明年要怎麼排程,

58:41.940 --> 58:54.940
所以我事實上是有辦法用這樣子的方式一直往更好的解去收斂,而不是每年都random重排一次。那這樣子的話,每個方法的差異大概是在哪裡?」

59:11.940 --> 59:13.940
主持人:「嗯,聽得到。」

59:13.940 --> 59:42.940
主持人:「好,感恩。就是說,我們先忘了我們剛剛講的那什麼1.33啊,什麼二分之一那類的事情的話,總之這是一個實際上要解決的問題,有一堆船要來,然後我們要跑,然後我們要把它們遷完,我們要讓我們的目標盡量好嘛,那你當然可以每年每年的看情況,你的演算法會做一些調整,實務上在跑的時候,演算法一定可以讓你調,然後你演算法有些參數,它會做一些setting之類的,weight啊什麼之類的,這都OK。」

59:42.940 --> 01:00:12.920
主持人:「所以您剛剛講的肯定沒有問題,就是你要解實務上的問題的話,你會依照環境和這個情況的變化,然後來做調整,那這跟理論上我們去思考一個演算法,它的performance guarantee是兩件事情,就是我今天給你一千條船,一百條船,你用任何的演算法去排,只要它不是最佳解,你就不知道你離最佳解有多遠嘛,因為你根本不知道最佳解是多少,對吧?

01:00:13.400 --> 01:00:40.900
所以你排出來,大家都很爽,你排出來,有些人不爽,但是你總之是不知道你離最佳解有多遠,OK?那演算法的理論性質,那個什麼upper bound,lower bound的,它就是在告訴我們,我們的演算法離最佳解可能有多遠,最遠遠到什麼程度,對,所以這個是兩件事情,實務上我們只要排出來的solution,大家可以接受,大家覺得OK就好了,

01:00:41.220 --> 01:00:48.180
那只是理論上、學術上,我們想要再更進一步的知道,我們離最佳解可能會有多遠,大概是這樣子吧。

01:00:48.180 --> 01:00:51.180
整理&字幕由Amara.org社區提供

01:01:18.180 --> 01:01:35.160
主持人問:「有沒有具體quantify說什麼樣的演算法好解釋,或什麼樣的演算法不好解釋的具體quantification呢?」

01:01:35.160 --> 01:01:54.360
主持人回答:「就我所知應該是沒有,因為解釋是解釋給人聽的嘛,那所謂的人能不能接受這種解釋,我並沒有什麼15秒之內人能接受就叫做好,然後15秒以上就不好了,這種15秒的這種quantification。」

01:01:54.560 --> 01:02:19.000
那大概只能很含糊地說,我們的演算法,首先,它為什麼在某些情況下表現得好表現得不好,要說得出一番道理來,然後它為什麼把這個工作分給你而不是分給它,要說得出演算法的弱來這樣子,那

01:02:20.000 --> 01:02:30.280
所以它還是一個比較直性的說明方式,就是沒有一個所謂的什麼可指標、可解釋性指標,基本上應該是沒有啦,這樣。

01:02:30.280 --> 01:02:53.480
主持人問:「那我把你的話再重新說一次好了,就是我聽起來這樣子的話可能有兩個不同方向的指標,一個是演算法要解釋為什麼這個工作分給A不分給B,

01:02:53.920 --> 01:03:07.380
這件事情本身好像可以對應到演算法本身就弱不能太複雜這樣子,可能就只有兩三行弱,就叫做簡單這樣子好解釋,這是第一個。

01:03:07.380 --> 01:03:36.440
然後第二個好像是比較像是解釋說,worst case,我也不太確定是不是worst case,或者是某一個case會怎麼分,然後這個case要夠簡單,然後大家才相信這個演算法好或不好這樣子,是這樣子的意思嗎?」

01:03:37.380 --> 01:03:50.840
沒有錯,對,就是可解釋性包含您剛剛講的這幾個不同的面向,就是為什麼演算法這麼做,為什麼在這個步驟把這個工作分給那個人,這是一種解釋性。

01:03:50.840 --> 01:04:05.020
然後就是為什麼工作少或工作多的時候,或者是工作緊、工作鬆的時候等等,為什麼在這個情境演算法跑得比那個情境來得好,這樣子,對,這兩種都是所謂的可解釋性的範圍。

01:04:05.140 --> 01:04:29.420
那以我淺薄的理解啊,我們如果是工程師的思維的話,工程師的重點在解決問題,所以演算法只要表現好再說,所以解釋性可能相對的也沒有那麼重要,那就很像現在深度學習,那些類神經網路等等的,他們都很準,那暫時人們還沒辦法解釋為什麼他們這麼準,不過不管,反正先用再說。

01:04:29.540 --> 01:04:45.180
那學術會慢慢地從解釋性的方面去跟上,然後就是,哦,他真的這麼準,總要有個原因,那有原因以後才有辦法複製嘛,所以大家就會去找解釋性,這樣,所以解釋性這種東西學術上也很重要。

01:04:45.180 --> 01:05:15.140
那回到我們剛剛講的問題的話,為什麼我們的問題在實務上也很重視解釋性,只是一個特例,就是因為我們的解釋的對象是那些什麼背牌班的人,那他們care公平性,很多時候care的是不要背黑箱,所以這個演算法對他們來說他們都不大懂,所以就覺得是黑箱嘛,所以必須要在有爭議的時候要能夠解釋為什麼會這麼安排,大概是這個樣子吧,對,不過也算是。

01:05:15.640 --> 01:05:20.680
這些資訊方法在實務上要應用的時候,有時候會遇到的問題就是了。

01:05:20.680 --> 01:05:46.900
主持人問:「我記得剛剛講黑箱的時候是有一個example是說,假如我是設計這個演算法的人,然後我可能我本身就是個黑箱嘛,然後我會跟某些人串通好,

01:05:47.900 --> 01:06:09.640
這個黑箱給他們特別爽或特別糟的,應該沒有人想要特別糟然後串通這樣子,但是這個是設計的人黑箱這件事情,這個跟可解釋性好像又是另外一個概念,

01:06:09.640 --> 01:06:34.660
因為有沒有串通或者有沒有黑箱這件事情,我覺得數學上好像比人腦這十五秒內能不能接受這一點更可以用數學的方式去表達或檢查它是不是滿足這樣的條件。

01:06:34.660 --> 01:06:43.460
我還沒有想到很具體的方式,但是我覺得有沒有串通或有沒有黑箱這件事情好像是比較容易用數學處理的。」

01:06:44.460 --> 01:06:47.460
主持人:「嗯,那挺好的,對吧?」

01:06:47.460 --> 01:06:49.460
主持人:「嗯,是喔。」

01:06:49.460 --> 01:06:51.460
主持人:「嘿嘿,好喔。」

01:06:51.460 --> 01:06:53.460
主持人:「那我也想要問個問題。」

01:06:53.460 --> 01:06:55.460
主持人:「好喔。」

01:06:56.460 --> 01:06:58.460
主持人:「那我也想要問個問題。」

01:06:58.460 --> 01:07:00.460
主持人:「好喔。」

01:07:00.460 --> 01:07:27.460
主持人:「就是你現在有這套演算法,那就是我想問的是說,在實務的時候啊,就是譬如說那個飲水人的這個問題,那你可能根據去年前年的資料,你可能知道這個船的比例是怎麼樣的,你的工作來的workload的比例是怎麼樣,可能大船多少小船多少。」

01:07:27.460 --> 01:07:43.460
主持人:「那就是實務上會根據,因為你的,就是我的意思是說你的instance不是random的,那就是實務上會根據這樣的就是不是random的instance來設計演算法嗎?」

01:07:43.460 --> 01:08:12.460
主持人:「嗯,當然會囉,對。就是,比如說工作要來,它一定有尖峰離峰,高雄港的話它夜間進來,高雄港要加乘,就收費要加乘,所以大部分的船都會在白天的時候進來,然後特別是早上七點的時候,七點到八點的時候會來二十幾條,那一天也才一百多條嘛,因為大部分的船它如果五六點到,它就會在外海鬼混一下,然後等到七點的時候再進來。」

01:08:12.960 --> 01:08:41.460
主持人:「所以,呃,你排工作肯定會考慮它們不是random instance,考慮那些pattern,那你都已經知道早上七點工作量特別大,那邏輯上來說你當然就是七點左右要特別多人在那邊值班,這一類的囉,那所以做相對應的因應是必然的,那當然說是這麼說啦,實務上能不能做到是另外一回事,比如說他們高雄港的引水人們,他們排班有他們排班,

01:08:41.460 --> 01:09:01.460
應該說他們輪班有他們輪班既有的規則,一個人就是輪二十四小時,然後呃,我們也跟他們討論過,欸,那七點白天特別多,那就人多一點,somehow就是不行,for some reason,對啊,不過這個好像不是重點,重點就是您說的這個肯定是會去處理的,

01:09:01.460 --> 01:09:29.460
那實務上演算法自然就會從我們剛剛講的那個聽起來很簡單的演算法去做一些微調,大概是這樣子吧,ok,對,那我想大家應該都很容易理解,就是寫paper的演算法跟實務的演算法顯然會有差別,演算法在學術上要做討論的時候一定是相對抽象的情境,用相對嗯。

01:09:31.460 --> 01:10:00.460
相對單純的演算法去處理,那單純不表示簡單,只是實務的情境會有,呃,有兩個原則就會有五十八個例外嘛,所以實務上演算法大部分的時候都是處理那些例外,然後處理那些你看得到的pattern,既然這個時候會有特別多人進來,你這個時候就多放幾個人在那邊,大概是這樣子,對啊,不過這些事情確實都是一定會做的,只是跟呃,實務的要求跟學術的要求就會不大一樣這樣。

01:10:01.460 --> 01:10:30.460
嗯,那實務上你們也會跑一些就是模擬嗎之類的,哦,會會會會會,因為呃,呃,現在已經談實務問題嘛,所以剛剛跟他們paper已經沒有關係了,實務上的這些工作時間是隨機的,就你說你要派一個人去外海把一條船帶進來,歷史上的資料讓你可以估計這個大概要六十八分鐘吧,但實際上可能會是七十八分鐘,五十二分鐘都有可能,所以實際上他的確有distribution,

01:10:30.460 --> 01:10:50.460
那distribution會受到天后啊,飲水人是誰啊,船的大小啊,吃水頓味等等的影響,所以真的到了要做實務演算法的時候,勢必就要做simulation才能夠比較合理的去evaluate演算法的好壞,對,沒錯。

01:10:50.460 --> 01:11:17.460
哇,這個聽起來是很複雜的事情啊,好,嗯,我也這麼覺得,對,就是他實務的問題講下去的話又可以再講個兩個小時之類的,就是他有很多詭異的事情啊,比如說,照理說你這個幾點幾分船應該要出港了,結果飲水人到了現場以後才發現他船隻還在上下貨,這也是很正常的嘛,或者是船有時候會拋錨啊,故障啊,然後這個。

01:11:17.460 --> 01:11:29.460
然後明明塔台已經安排好,這一艘船先出來,然後那一艘船再進去,有的時候會有人插隊啊,所以後面就會打亂,那實務上就是處理這些問題嘛,對。

01:11:30.460 --> 01:11:37.460
這個是不是在機場也是很多時候類似的問題啊?

01:11:37.460 --> 01:12:04.460
哦,對啊,機場的話就是,呃,機場一樣有人員排班,然後飛機起降,所以問題性質相當於像,然後他這個機場的飛機起降也會有很多意想不到的事情,對啊,所以大部分的時候這些演算法就是他裡面會有各式各樣的if else,就是如果某件事情發生的話,你就趕快do this do that,對。

01:12:05.460 --> 01:12:11.460
OK,好,呃,那大家還沒有什麼問題呢?

01:12:13.460 --> 01:12:18.460
其實我還有一個問題,但是我想在那個結束之後再問,因為比較沒有關係。

01:12:18.460 --> 01:12:36.460
好,那如果沒有要問的問題的話,那我們就先謝謝孔教授精彩的演講吧,感謝大家,祝大家青春愉快,那我們現在先把錄影關掉了,哦,好。

